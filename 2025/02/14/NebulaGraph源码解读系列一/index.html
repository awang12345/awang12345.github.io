<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>NebulaGraph源码解读系列一 | 技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="源码分支： release-3.6 作者简介：阿旺（奇富科技）本人是一名 java 老鸟，工作内容并非 C++ 方向，平时也很少接触 C++ 语言，不懂的代码都是使用 GPT 作代码辅助解释，故难免存在准确性问题，但大体思路应该没太大问题，如有错误问题还望评论区指出回复，相互学习共同成长。以下内容源自我在使用 NebulaGraph 过程中遇到的一些问题和思考。我通过查阅源码、动手实践，解决了一些">
<meta property="og:type" content="article">
<meta property="og:title" content="NebulaGraph源码解读系列一">
<meta property="og:url" content="http://example.com/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="源码分支： release-3.6 作者简介：阿旺（奇富科技）本人是一名 java 老鸟，工作内容并非 C++ 方向，平时也很少接触 C++ 语言，不懂的代码都是使用 GPT 作代码辅助解释，故难免存在准确性问题，但大体思路应该没太大问题，如有错误问题还望评论区指出回复，相互学习共同成长。以下内容源自我在使用 NebulaGraph 过程中遇到的一些问题和思考。我通过查阅源码、动手实践，解决了一些">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-14T08:27:59.000Z">
<meta property="article:modified_time" content="2025-02-14T08:32:24.701Z">
<meta property="article:author" content="Jiangyiwang">
<meta property="article:tag" content="图数据库">
<meta property="article:tag" content="NebulaGraph">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">阿旺, 作者简介：目前就职于某头部金融科技公司，13年Java开发，开源NebulaGraph图数据库Contributer和Committer, 热衷于疑难问题解决</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-NebulaGraph源码解读系列一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T08:27:59.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      NebulaGraph源码解读系列一
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>源码分支：</strong> release-3.6</p>
<h4 id="作者简介："><a href="#作者简介：" class="headerlink" title="作者简介："></a>作者简介：</h4><p>阿旺（奇富科技）<br>本人是一名 java 老鸟，工作内容并非 C++ 方向，平时也很少接触 C++ 语言，不懂的代码都是使用 GPT 作代码辅助解释，故难免存在准确性问题，但大体思路应该没太大问题，如有错误问题还望评论区指出回复，相互学习共同成长。以下内容源自我在使用 NebulaGraph 过程中遇到的一些问题和思考。我通过查阅源码、动手实践，解决了一些实际生产中的疑难问题。也希望借此与大家分享经验，探讨更多技术细节。同时，也想鼓励每一位技术人——不要给自己轻易设限，勇于突破边界，探索新的领域。</p>
<h5 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h5><ol>
<li>nebula目录结构说明</li>
<li>nebula启动会运行多少个rocksdb实例</li>
<li>nebula是如何查询一个点的数据</li>
<li>nebula中value是如何编码的</li>
<li>nebula中TTL是如何实现的</li>
<li>nebula中如何管理session</li>
<li>nebula错误日志中未知错误码如何定位原因</li>
</ol>
<h5 id="一、nebula源码src目录结构"><a href="#一、nebula源码src目录结构" class="headerlink" title="一、nebula源码src目录结构"></a>一、nebula源码src目录结构</h5><p><strong>src</strong><br>|-<strong>clients</strong> : 内部服务客户端，主要用于graphd、metad、storaged内部服务RPC调用<br>|-<strong>codec</strong> ：nebula数据的key-value编码和解码<br>|-<strong>daemons</strong> ：启动入口，graphd、metad、storaged启动<br>|-<strong>graph</strong> ：graphd相关业务实现，graphd主要负责处理客户端请求，属于nebula的计算层<br>|-<strong>interface</strong> : thrift接口定义，nebula采用thrift做异构语言rpc调用，nebula客户端与nebula交互接口皆定义于此<br>|-<strong>kvstore</strong> ：键值存储引擎，storaged和metad都会用到，比如：rocksdb和hbase，nebula默认采用rocksdb作为内嵌存储<br>|-<strong>meta</strong> ：元数据相关，比如：session会话、用户信息、分片信息等等，属于nebula元数据管理层<br>|-<strong>parser</strong> : 语法解析<br>|-<strong>storage</strong> : nebula存储相关，提供一些简单的kv存储和查询的接口服务给graphd调用</p>
<p><strong>温馨提示：</strong> nebula通过CMake进行编译打包，如果想了解打包过程和依赖信息见每个目录的CMakeLists.txt文件</p>
<h6 id="二、单个nebula-storaged启动时会运行多少个rocksdb实例"><a href="#二、单个nebula-storaged启动时会运行多少个rocksdb实例" class="headerlink" title="二、单个nebula-storaged启动时会运行多少个rocksdb实例"></a>二、单个nebula-storaged启动时会运行多少个rocksdb实例</h6><p><strong>结论：</strong> 数据存储磁盘目录数 *space总数<br>数据存储磁盘目录： etc&#x2F;nebula-storaged.conf中data_path<br>比如：有2个space，3个数据目录，则rocksdb实例数&#x3D;2*3&#x3D;6</p>
<p><strong>相关知识点：</strong><br>space和part分区数越多nebula-storaged启动越慢</p>
<p><strong>大体过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.StorageDaemon::main() 程序启动入口</span><br><span class="line">2.StorageServer::start() 启动存储引擎</span><br><span class="line">3.StorageServer::getStoreInstance() 初始化存储引擎</span><br><span class="line">4.NebulaStore::init() nebula存储引擎初始化</span><br><span class="line">5.NebulaStore::loadPartFromDataPath() 通过获取data_path存储目录路径，为每个目录下space启动一个rocksdb实例，并且建立了space和kvEngine的映射关系，以及partId和part的映射关系，后面查询或者更新实则是定位数据partId，然后通过partId获取到part进行操作，part中保留了kvEngine的引用</span><br><span class="line"></span><br><span class="line">最终构建spaces_，里面包含了SpaceId和spacePart分片的映射关系，后面所有的读写都需要此映射关系操作对应的rocksdb，这里的映射关系类似于java中SpringBean</span><br><span class="line">std::unordered_map&lt;GraphSpaceID, std::shared_ptr&lt;SpacePartInfo&gt;&gt; spaces_;</span><br><span class="line">struct SpacePartInfo &#123;</span><br><span class="line">  //Part中保留了engin的引用，当前版本engine其实就是rocksdb</span><br><span class="line">  std::unordered_map&lt;PartitionID, std::shared_ptr&lt;Part&gt;&gt; parts_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt; engines_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>关键代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建storageServer并启动</span></span><br><span class="line">StorageDaemon::<span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">auto</span> storageServer = std::<span class="built_in">make_unique</span>&lt;nebula::storage::StorageServer&gt;(</span><br><span class="line">      localhost, metaAddrsRet.<span class="built_in">value</span>(), paths, FLAGS_wal_path, FLAGS_listener_path);</span><br><span class="line">    storageServer-&gt;<span class="built_in">start</span>()  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化kv存储引擎</span></span><br><span class="line">StorageServer::<span class="built_in">start</span>()&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Init kvstore&quot;</span>;</span><br><span class="line">  kvstore_ = <span class="built_in">getStoreInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化nebula存储引擎并初始化</span></span><br><span class="line">StorageServer::<span class="built_in">getStoreInstance</span>()&#123;</span><br><span class="line">    <span class="keyword">auto</span> nbStore = std::<span class="built_in">make_unique</span>&lt;kvstore::NebulaStore&gt;(</span><br><span class="line">        std::<span class="built_in">move</span>(options), ioThreadPool_, localHost_, workers_);</span><br><span class="line">    nbStore-&gt;<span class="built_in">init</span>()        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从data_path中载入part分区数据</span></span><br><span class="line">NebulaStore::<span class="built_in">init</span>()&#123;</span><br><span class="line">    <span class="built_in">loadPartFromDataPath</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历data_path目录为每个space创建一个rocksdb引擎</span></span><br><span class="line">NebulaStore::<span class="built_in">loadPartFromDataPath</span>()&#123;</span><br><span class="line">    std::vector&lt;folly::Future&lt;std::pair&lt;GraphSpaceID, std::unique_ptr&lt;KVEngine&gt;&gt;&gt;&gt; futures;</span><br><span class="line">  std::vector&lt;std::string&gt; enginesPath;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; path : options_.dataPaths_) &#123;</span><br><span class="line">    <span class="comment">//这里其实就是data_path，比如:/usr/local/nebula/data</span></span><br><span class="line">    <span class="keyword">auto</span> rootPath = folly::<span class="built_in">stringPrintf</span>(<span class="string">&quot;%s/nebula&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//获取每个data_pah子目录，其实就是space</span></span><br><span class="line">    <span class="comment">// 比如 /usr/local/nebula/data/1、/usr/local/nebula/data/2</span></span><br><span class="line">    <span class="keyword">auto</span> dirs = fs::FileUtils::<span class="built_in">listAllDirsInDir</span>(rootPath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//遍历space目录，为每个space目录创建一个rocksdb</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">      <span class="comment">//目录名称就是spaceId，比如/usr/local/nebula/data/1中的1就是spaceId</span></span><br><span class="line">      GraphSpaceID spaceId = folly::<span class="built_in">to</span>&lt;GraphSpaceID&gt;(dir);</span><br><span class="line">      <span class="comment">// 目录为0的跳过</span></span><br><span class="line">      <span class="keyword">if</span> (spaceId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// skip the system space, only handle data space here.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      enginesPath.<span class="built_in">emplace_back</span>(rootPath + <span class="string">&quot;/&quot;</span> + dir);</span><br><span class="line">      <span class="comment">//异步创建rocksdb存储引擎</span></span><br><span class="line">      futures.<span class="built_in">emplace_back</span>(<span class="built_in">newEngineAsync</span>(spaceId, path, options_.walPath_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// space和kvEngine列表的映射关系</span></span><br><span class="line">    std::unordered_map&lt;GraphSpaceID, std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt;&gt; spaceEngines;</span><br><span class="line">    <span class="comment">// 等待并获取前面的异步创建引擎列表</span></span><br><span class="line">    <span class="keyword">auto</span> tries = folly::<span class="built_in">collectAll</span>(futures).<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : tries) &#123;</span><br><span class="line">        <span class="comment">//p就是个二元组，第一个元素为space，第二个元素为kvEngine</span></span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; p = t.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">auto</span> spaceIt = spaceEngines.<span class="built_in">find</span>(p.first);</span><br><span class="line">        <span class="keyword">if</span> (spaceIt == spaceEngines.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        spaceIt = spaceEngines.<span class="built_in">emplace</span>(p.first, std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt;()).first;</span><br><span class="line">      &#125;</span><br><span class="line">        spaceIt-&gt;second.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(p.second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有space存储引擎</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; spaceEngine : spaceEngines) &#123;</span><br><span class="line">        GraphSpaceID spaceId = spaceEngine.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; engine : spaceEngine.second) &#123;</span><br><span class="line">          <span class="comment">// part分片与part副本节点集合，后面raft需要用到</span></span><br><span class="line">          std::map&lt;PartitionID, Peers&gt; partRaftPeers;</span><br><span class="line">          partRaftPeers.<span class="built_in">emplace</span>(partId, raftPeers);</span><br><span class="line">          <span class="comment">//建立起partId和part映射关系，后面操作某partId的数据时就是通过part进行的，part中其实保留了kvEngine的引用</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : partRaftPeers) &#123;</span><br><span class="line">                <span class="keyword">auto</span> part = <span class="built_in">newPart</span>(spaceId, partId, enginePtr, isLearner, addrs);</span><br><span class="line">                <span class="keyword">auto</span> ret = iter-&gt;second-&gt;parts_.<span class="built_in">emplace</span>(partId, part);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建rocksdb引擎</span></span><br><span class="line">NebulaStore::<span class="built_in">newEngineAsync</span>() &#123;</span><br><span class="line">      engine = std::<span class="built_in">make_unique</span>&lt;RocksEngine&gt;(</span><br><span class="line">          spaceId, vIdLen, dataPath, walPath, options_.mergeOp_, cfFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="三、nebula是如何查询一个点的数据"><a href="#三、nebula是如何查询一个点的数据" class="headerlink" title="三、nebula是如何查询一个点的数据"></a>三、nebula是如何查询一个点的数据</h6><p>graphd负责接受client客户端请求，并解析 nGQL，生成查询计划，再经过优化器，最终执行executor，为了突出重点省去从接受请求开始到调用executor，而直接定位executor，这边以GetVerticesExecutor.cpp为例来探究如何查找vertex点的数据，主要探究vertexId如何定位到数据</p>
<p><strong>相关知识点</strong> </p>
<ol>
<li>part数和storaged查询并发数成正比</li>
<li>vid和partId映射计算公式: partId &#x3D; hash(vid) % numParts + 1</li>
</ol>
<p><strong>大体过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//nebula-graphd</span><br><span class="line">1.GetVerticesExecutor::getVertices() 获取多个点属性列表</span><br><span class="line">2.StorageClient::getProps() 计算vertexId对应的part，然后请求对应part分片数据</span><br><span class="line"></span><br><span class="line">//nebula-storaged</span><br><span class="line">3.GraphStorageServiceHandler::future_getProps() storagd收到graphd来的请求进行处理</span><br><span class="line">4.GetPropProcessor::doProcess()  构建tag属性查询计划并调用</span><br><span class="line">5.GetTagPropNode::doExecute()  根据vid构建rocksdb的key，然后调用NebulaStore进行获取</span><br><span class="line">6.NebulaStore::get() 通过partId定位出part，然后通过part获取对应key的信息</span><br><span class="line">7.RocksEngine::get() 从rocksdb中获取数据</span><br></pre></td></tr></table></figure>
<p><strong>关键源码</strong><br>nebula-graphd部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过上下文获取到storageClient然后调用获取属性的方法</span></span><br><span class="line">GetVerticesExecutor::<span class="built_in">getVertices</span>() &#123;</span><br><span class="line">    StorageClient *storageClient = <span class="built_in">qctx</span>()-&gt;<span class="built_in">getStorageClient</span>();</span><br><span class="line">    storageClient-&gt;<span class="built_in">getProps</span>(param,</span><br><span class="line">                 std::<span class="built_in">move</span>(vertices),</span><br><span class="line">                 gv-&gt;<span class="built_in">props</span>(),</span><br><span class="line">                 <span class="literal">nullptr</span>,</span><br><span class="line">                 gv-&gt;<span class="built_in">exprs</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">dedup</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">orderBy</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">getValidLimit</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">filter</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过vertexId获取到part所在节点信息</span></span><br><span class="line"><span class="comment">// 请求对应节点的vertexId信息</span></span><br><span class="line"><span class="function">StorageRpcRespFuture&lt;cpp2::GetPropResponse&gt; <span class="title">StorageClient::getProps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立vertexId和part节点映射关系</span></span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">clusterIdsToHosts</span>(param.space, input.rows, std::<span class="built_in">move</span>(cbStatus).<span class="built_in">value</span>());</span><br><span class="line">  <span class="comment">// 为不同的节点构建对应的request</span></span><br><span class="line">  cpp2::GetPropRequest&gt; requests;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : clusters) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; host = c.first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; req = requests[host];</span><br><span class="line">    req.<span class="built_in">space_id_ref</span>() = param.space;</span><br><span class="line">    req.<span class="built_in">parts_ref</span>() = std::<span class="built_in">move</span>(c.second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用rpc请求storaged获取点的属性信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">collectResponse</span>(</span><br><span class="line">      param.evb, std::<span class="built_in">move</span>(requests), [](ThriftClientType* client, <span class="type">const</span> cpp2::GetPropRequest&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> client-&gt;<span class="built_in">future_getProps</span>(r);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过（vid % numParts + 1）计算出对应的part</span></span><br><span class="line"><span class="comment">// 这种方式也预示着space设定的分区数量一旦创建不可更改，否则数据就会映射不上</span></span><br><span class="line">StorageClientBase::<span class="built_in">clusterIdsToHosts</span>()&#123;</span><br><span class="line">    <span class="comment">//获取space空间有多少个part</span></span><br><span class="line">  <span class="keyword">auto</span> status = metaClient_-&gt;<span class="built_in">partsNum</span>(spaceId);</span><br><span class="line">  std::unordered_map&lt;PartitionID, HostAddr&gt; leaders;</span><br><span class="line">    <span class="comment">//建立起partId和leader节点的映射关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> partId = <span class="number">1</span>; partId &lt;= numParts; ++partId) &#123;</span><br><span class="line">    <span class="keyword">auto</span> leader = <span class="built_in">getLeader</span>(spaceId, partId);</span><br><span class="line">    leaders[partId] = std::<span class="built_in">move</span>(leader).<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; id : ids) &#123;</span><br><span class="line">        <span class="comment">// 计算vid对应的partId</span></span><br><span class="line">        PartitionID part = vid % numParts + <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; leader = leaders[part];</span><br><span class="line">        clusters[leader][part].<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(id));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clusters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nebula-storaged部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">folly::Future&lt;cpp2::GetPropResponse&gt; <span class="title">GraphStorageServiceHandler::future_getProps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cpp2::GetPropRequest&amp; req)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* processor = GetPropProcessor::<span class="built_in">instance</span>(env_, &amp;kGetPropCounters, readerPool_.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RETURN_FUTURE</span>(processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetPropProcessor::<span class="built_in">doProcess</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!FLAGS_query_concurrently) &#123;</span><br><span class="line">     <span class="comment">//为了方便理解，这里直接选择单线程</span></span><br><span class="line">      <span class="built_in">runInSingleThread</span>(req);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">runInMultipleThread</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetPropProcessor::<span class="built_in">runInSingleThread</span>()&#123;</span><br><span class="line">    <span class="comment">// 构建tag查询计划,这个计划相当于构建一个DAG</span></span><br><span class="line">    <span class="comment">// 里面有完整的依赖信息</span></span><br><span class="line">    <span class="keyword">auto</span> plan = <span class="built_in">buildTagPlan</span>(&amp;contexts_.<span class="built_in">front</span>(), &amp;resultDataSet_);</span><br><span class="line">    <span class="comment">// 遍历待查询的part分区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; partEntry : req.<span class="built_in">get_parts</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> partId = partEntry.first;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : partEntry.second) &#123;</span><br><span class="line">        <span class="keyword">auto</span> vId = row.values[<span class="number">0</span>].<span class="built_in">getStr</span>();</span><br><span class="line">        <span class="comment">// 执行查询计划</span></span><br><span class="line">        plan.<span class="built_in">go</span>(partId, vId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建执行计划DAG</span></span><br><span class="line">GetPropProcessor::<span class="built_in">buildTagPlan</span>(RuntimeContext* context,</span><br><span class="line">                                                     nebula::DataSet* result) &#123;</span><br><span class="line">  StoragePlan&lt;VertexID&gt; plan;</span><br><span class="line">  std::vector&lt;TagNode*&gt; tags;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tc : tagContext_.propContexts_) &#123;</span><br><span class="line">    <span class="comment">// TagNode获取vid指定tag的属性列表，TagNode will return a DataSet of specified props of tagId</span></span><br><span class="line">    <span class="comment">// 这里面就有从rocksdb中读取tag的value属性</span></span><br><span class="line">    <span class="comment">// 查询语句指定多少个tag，这里就会有多少个TagNode</span></span><br><span class="line">    <span class="comment">// 比如：fetch prop on tag_1,tag_2,tag_3 idxxx,那这里就有3个TagNode</span></span><br><span class="line">    <span class="keyword">auto</span> tag = std::<span class="built_in">make_unique</span>&lt;TagNode&gt;(context, &amp;tagContext_, tc.first, &amp;tc.second);</span><br><span class="line">    tags.<span class="built_in">emplace_back</span>(tag.<span class="built_in">get</span>());</span><br><span class="line">    plan.<span class="built_in">addNode</span>(std::<span class="built_in">move</span>(tag));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// GetTagPropNode用于收集vid对应多个tag的属性</span></span><br><span class="line">  <span class="keyword">auto</span> output = std::<span class="built_in">make_unique</span>&lt;GetTagPropNode&gt;(</span><br><span class="line">      context, tags, result, filter_ == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : filter_-&gt;<span class="built_in">clone</span>(), limit_, &amp;tagContext_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>* tag : tags) &#123;</span><br><span class="line">    output-&gt;<span class="built_in">addDependency</span>(tag);</span><br><span class="line">  &#125;</span><br><span class="line">  plan.<span class="built_in">addNode</span>(std::<span class="built_in">move</span>(output));</span><br><span class="line">  <span class="keyword">return</span> plan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TagNode::<span class="built_in">doExecute</span>()&#123;</span><br><span class="line">    <span class="comment">// 根据vid和tagId构建rocksdb中key</span></span><br><span class="line">    key_ = NebulaKeyUtils::<span class="built_in">tagKey</span>(context_-&gt;<span class="built_in">vIdLen</span>(), partId, vId, tagId_);</span><br><span class="line">    <span class="comment">// 从响应分片的rocksdb中获取value，此value为经过RowWriter编码的value</span></span><br><span class="line">    ret = context_-&gt;<span class="built_in">env</span>()-&gt;kvstore_-&gt;<span class="built_in">get</span>(context_-&gt;<span class="built_in">spaceId</span>(), partId, key_, &amp;value_);</span><br><span class="line">    <span class="comment">// RowReaderWrapper设置schema和对应的value，后面用于GetTagPropNode收集prop做准备</span></span><br><span class="line">    reader_.<span class="built_in">reset</span>(*schemas_, value_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集vid对应所有tag的属性值列表</span></span><br><span class="line">GetTagPropNode::<span class="built_in">doExecute</span>()&#123;</span><br><span class="line">    <span class="comment">// 这个集合用于保存查询到的vid对应不同tag的属性集合</span></span><br><span class="line">    List row;</span><br><span class="line">    <span class="comment">// vertexId is the first column</span></span><br><span class="line">    <span class="keyword">if</span> (context_-&gt;<span class="built_in">isIntId</span>()) &#123;</span><br><span class="line">      row.<span class="built_in">emplace_back</span>(*<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">int64_t</span>*&gt;(vId.<span class="built_in">data</span>()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      row.<span class="built_in">emplace_back</span>(vId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历本次要查询的所有tag</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* tagNode : tagNodes_) &#123;</span><br><span class="line">      ret = tagNode-&gt;<span class="built_in">collectTagPropsIfValid</span>(</span><br><span class="line">          <span class="comment">// 收集tagNode中属性到row中</span></span><br><span class="line">          [&amp;row, vIdLen, isIntId, tagNode, <span class="keyword">this</span>]()&#123;</span><br><span class="line">            <span class="keyword">auto</span> status = QueryUtils::<span class="built_in">collectVertexProps</span>(</span><br><span class="line">                key, vIdLen, isIntId, reader, props, row, expCtx_.<span class="built_in">get</span>(), tagNode-&gt;<span class="built_in">getTagName</span>());</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryUtils::<span class="built_in">collectVertexProps</span>()&#123;</span><br><span class="line">  <span class="comment">// 遍历tag中的属性列表，挨个的取出来放入到list中，这个list就是GetTagPropNode::doExecute中的row</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; prop : *props) &#123;</span><br><span class="line">      <span class="keyword">auto</span> value = QueryUtils::<span class="built_in">readVertexProp</span>(key, vIdLen, isIntId, reader, prop);</span><br><span class="line">      list.<span class="built_in">emplace_back</span>(value.<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性值</span></span><br><span class="line">QueryUtils::<span class="built_in">readVertexProp</span>()&#123;</span><br><span class="line">  <span class="keyword">switch</span> (prop.propInKeyType_) &#123;</span><br><span class="line">      <span class="comment">// prop in value</span></span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::NONE: &#123;</span><br><span class="line">        <span class="comment">// ddl中的属性，这里的readValue就是RowReader根据schame获取字段的offset，然后获取对应的field值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">readValue</span>(reader, prop.name_, prop.field_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::VID: &#123;</span><br><span class="line">        <span class="comment">// 属性类型为vid</span></span><br><span class="line">        <span class="keyword">auto</span> vId = NebulaKeyUtils::<span class="built_in">getVertexId</span>(vIdLen, key);</span><br><span class="line">        <span class="keyword">if</span> (isIntId) &#123;</span><br><span class="line">          <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">int64_t</span>*&gt;(vId.<span class="built_in">data</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> vId.<span class="built_in">subpiece</span>(<span class="number">0</span>, vId.<span class="built_in">find_first_of</span>(<span class="string">&#x27;\0&#x27;</span>)).<span class="built_in">toString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::TAG: &#123;</span><br><span class="line">        <span class="comment">// 属性类型为tagId</span></span><br><span class="line">        <span class="keyword">auto</span> tag = NebulaKeyUtils::<span class="built_in">getTagId</span>(vIdLen, key);</span><br><span class="line">        <span class="keyword">return</span> tag;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="四、nebula中value是如何编码的"><a href="#四、nebula中value是如何编码的" class="headerlink" title="四、nebula中value是如何编码的"></a>四、nebula中value是如何编码的</h6><p>从2.x开始起nebula使用新的编码方式version 2，由5个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt; &lt;schema version&gt; &lt;NULL flags&gt; &lt;all properties&gt; &lt;string content&gt;</span><br><span class="line">   |             |             |              |</span><br><span class="line"> 1 byte     0 - 7 bytes     0+ bytes       N bytes</span><br></pre></td></tr></table></figure>
<p><strong>header:</strong> 占用1个字节，用来标识schema version字节长度，目前取值0<del>7<br><strong>schema version：</strong> 0</del>7个字节,标识schema版本<br><strong>NULL flags:</strong> NULL字段标识，跟mysql设计类似，为NULL的字段就在对应的bit位设置为1<br><strong>all properties：</strong> 固定长度的属性值，根据schema进行排列，由于固定长度所以想获取某个字段的值可以直接计算offset+length就能拿到, 除 STRING 类型属性外，所有属性都就地存储。STRING 属性将字符串内容的偏移量存储在前 4 个字节中，将字符串的长度存储在后 4 个字节中。字符串内容将附加到编码字符串的末尾，相当于多了一层指针<br><strong>string content:</strong> 存储非固定长度的string字符串，获取string属性内容得多次计算，先计算string字符串指针位置，然后在根据指针报错的offset+length得到完整的string内容</p>
<p><strong>各类型占用内存空间大小：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL            (1 byte)</span><br><span class="line">INT8            (1 byte)</span><br><span class="line">INT16           (2 bytes)</span><br><span class="line">INT32           (4 bytes)</span><br><span class="line">INT64           (8 bytes)</span><br><span class="line">FLOAT           (4 bytes)</span><br><span class="line">DOUBLE          (8 bytes)</span><br><span class="line">STRING          (8 bytes) *</span><br><span class="line">FIXED_STRING    (Length defined in the schema)</span><br><span class="line">TIMESTAMP       (8 bytes)</span><br><span class="line">DATE            (4 bytes)</span><br><span class="line">DATETIME        (15 bytes)</span><br><span class="line">GEOGRAPHY       (8 bytes) *</span><br></pre></td></tr></table></figure>

<p><strong>关键代码：</strong><br>RowWriterV2.cpp和RowWriterV2.h</p>
<h6 id="五、nebula中TTL是如何实现的"><a href="#五、nebula中TTL是如何实现的" class="headerlink" title="五、nebula中TTL是如何实现的"></a>五、nebula中TTL是如何实现的</h6><p>nebula中TTL是通过rocksdb中KVFilter实现的，KVFilter是rocksdb对外保留的扩展接口，查询和compact时用来做数据的过滤，数据每次搜索时都会经过此Filter，nebula实现此接口用来过滤TTL过期的数据，以及rocksdb做compact时筛选出过期的数据让其删除。</p>
<p><strong>相关知识点：</strong><br>TTL到期的数据可能并未删除，仅仅只是查询不出来，如果此时加大TTL或者删除TTL，原来查询不到的数据又会查询出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVFilter在启动的rocksdb的时候就需要设置进去，所以这里直接看rocksdb启动的代码即可</span></span><br><span class="line">StorageServer::<span class="built_in">getStoreInstance</span>()&#123;</span><br><span class="line">	kvstore::KVOptions options;</span><br><span class="line">	<span class="comment">// 这个StorageCompactionFilter就是nebula给予VKFilter实现的</span></span><br><span class="line">	options.compaction_filter_factory = std::<span class="built_in">make_unique</span>&lt;StorageCompactionFilterFactoryBuilder&gt;(schemaMan_.<span class="built_in">get</span>(), indexMan_.<span class="built_in">get</span>());</span><br><span class="line">	status = rocksdb::DB::<span class="built_in">Open</span>(options, path, &amp;db);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StorageCompactionFilter</span> <span class="keyword">final</span> : <span class="keyword">public</span> kvstore::KVFilter &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里是filter的入口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">filter</span><span class="params">(<span class="type">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">              GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &lt; FLAGS_min_level_for_custom_filter) &#123;</span><br><span class="line">      <span class="comment">// for upper level such as L0/L1, we don&#x27;t go through the custom</span></span><br><span class="line">      <span class="comment">// validation to achieve better performance</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isTag</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">tagValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isEdge</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">edgeValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IndexKeyUtils::<span class="built_in">isIndexKey</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">indexValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!FLAGS_use_vertex_key &amp;&amp; NebulaKeyUtils::<span class="built_in">isVertex</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isLock</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">lockValid</span>(spaceId, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// skip uuid/system/operation</span></span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Skip the system key inside, key &quot;</span> &lt;&lt; key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断tag是否有效,这里其实就是比对ttl字段的值对比当前时间是否超过ttl</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">tagValid</span><span class="params">(GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ttlExpired</span>(schema.<span class="built_in">get</span>(), reader.<span class="built_in">get</span>())) &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Ttl expired&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//判断边是否过期</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">edgeValid</span><span class="params">(GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ttlExpired</span>(schema.<span class="built_in">get</span>(), reader.<span class="built_in">get</span>())) &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Ttl expired&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// TODO(panda) Optimize the method in the future</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ttlExpired</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                  nebula::RowReaderWrapper* reader)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (schema == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ttl = CommonUtils::<span class="built_in">ttlProps</span>(schema);</span><br><span class="line">    <span class="comment">// Only support the specified ttl_col mode</span></span><br><span class="line">    <span class="comment">// Not specifying or non-positive ttl_duration behaves like ttl_duration =</span></span><br><span class="line">    <span class="comment">// infinity</span></span><br><span class="line">    <span class="keyword">if</span> (!ttl.first) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里比对数据的ttl字段的值和当前时间，如果过期就返回true</span></span><br><span class="line">    <span class="keyword">return</span> CommonUtils::<span class="built_in">checkDataExpiredForTTL</span>(schema, reader, ttl.second.second, ttl.second.first);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ttlExpired</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema, <span class="type">const</span> Value&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (schema == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ttl = CommonUtils::<span class="built_in">ttlProps</span>(schema);</span><br><span class="line">    <span class="keyword">if</span> (!ttl.first) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CommonUtils::<span class="built_in">checkDataExpiredForTTL</span>(schema, v, ttl.second.second, ttl.second.first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断ttl是否过期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CommonUtils::checkDataExpiredForTTL</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> Value&amp; v,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; ttlCol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> ttlDuration)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; ftype = schema-&gt;<span class="built_in">getFieldType</span>(ttlCol);</span><br><span class="line">  <span class="keyword">if</span> (ftype != nebula::cpp2::PropertyType::TIMESTAMP &amp;&amp;</span><br><span class="line">      ftype != nebula::cpp2::PropertyType::INT64) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> now;</span><br><span class="line">  <span class="comment">// The unit of ttl expiration unit is controlled by user, we just use a gflag here.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_ttl_use_ms) &#123;</span><br><span class="line">    now = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    now = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(t.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the value is not INT type (sush as NULL), it will never expire.</span></span><br><span class="line">  <span class="comment">// TODO (sky) : DateTime</span></span><br><span class="line">  <span class="keyword">if</span> (v.<span class="built_in">isInt</span>() &amp;&amp; (now &gt; (v.<span class="built_in">getInt</span>() + ttlDuration))) &#123;</span><br><span class="line">    <span class="built_in">VLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;ttl expired&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ddl的schema里面读取ttl_duration和ttl_col字段</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">int64_t</span>, std::string&gt;&gt; CommonUtils::<span class="built_in">ttlProps</span>(</span><br><span class="line">    <span class="type">const</span> meta::NebulaSchemaProvider* schema) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(schema != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* ns = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> meta::NebulaSchemaProvider*&gt;(schema);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sp = ns-&gt;<span class="built_in">getProp</span>();</span><br><span class="line">  <span class="type">int64_t</span> duration = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (sp.<span class="built_in">get_ttl_duration</span>()) &#123;</span><br><span class="line">    duration = *sp.<span class="built_in">get_ttl_duration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::string col;</span><br><span class="line">  <span class="keyword">if</span> (sp.<span class="built_in">get_ttl_col</span>()) &#123;</span><br><span class="line">    col = *sp.<span class="built_in">get_ttl_col</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(!(duration &lt;= <span class="number">0</span> || col.<span class="built_in">empty</span>()), std::<span class="built_in">make_pair</span>(duration, col));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取ttl_col字段的值</span></span><br><span class="line"><span class="function">StatusOr&lt;Value&gt; <span class="title">CommonUtils::ttlValue</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      RowReaderWrapper* reader)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(schema != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* ns = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> meta::NebulaSchemaProvider*&gt;(schema);</span><br><span class="line">  <span class="keyword">auto</span> ttlProp = <span class="built_in">ttlProps</span>(ns);</span><br><span class="line">  <span class="keyword">if</span> (!ttlProp.first) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reader-&gt;<span class="built_in">getValueByName</span>(std::<span class="built_in">move</span>(ttlProp).second.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="六、nebula中是如何管理session的"><a href="#六、nebula中是如何管理session的" class="headerlink" title="六、nebula中是如何管理session的"></a>六、nebula中是如何管理session的</h6><p>session是客户端和服务端nebula-graphd交互的凭证，session保存在nebula-metad中，session的创建和销毁都需要跟nebula-metad交互，后面将分析session的创建和销毁。<br><strong>相关知识点</strong></p>
<ol>
<li>client客户端通过sessionId来标识session</li>
<li>nebula-graphd重启不会影响已创建的session</li>
<li>nebula-metad将session保存到rocksdb中</li>
</ol>
<p><strong>总体步骤</strong></p>
<ol>
<li>nebula-client创建连接并调用用户验证创建session</li>
<li>nebula-graphd接收到client的请求验证，并调用nebula-metad进行session创建</li>
<li>nebula-metad生成sessionId并通过raft协议进行保存</li>
</ol>
<p><strong>session的创建</strong><br>nebula-client-3.6 客户端代码：创建nebula连接并认证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nebula客户端创建连接都需要先进行用户名和密码验证，nebula服务端验证成功后将返回sessionId，客户端使用sessionId作为凭证操作nebula</span></span><br><span class="line"><span class="keyword">private</span> NebulaSession <span class="title function_">createSessionObject</span><span class="params">(SessionState state)</span>&#123;</span><br><span class="line">   <span class="type">SyncConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncConnection</span>();</span><br><span class="line">   <span class="comment">//建立连接</span></span><br><span class="line">   connection.open(getAddress(), sessionPoolConfig.getTimeout());</span><br><span class="line">   <span class="comment">//用户名密码认证</span></span><br><span class="line">   <span class="type">AuthResult</span> <span class="variable">authResult</span> <span class="operator">=</span> connection.authenticate(sessionPoolConfig.getUsername(),</span><br><span class="line">                    sessionPoolConfig.getPassword());</span><br><span class="line">   <span class="comment">//将认证结果sessionId放到NebulaSession中</span></span><br><span class="line">   <span class="type">NebulaSession</span> <span class="variable">nebulaSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NebulaSession</span>(connection, authResult.getSessionId(),</span><br><span class="line">                authResult.getTimezoneOffset(), state);</span><br><span class="line">   <span class="keyword">return</span> nebulaSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NebulaSession执行语句</span></span><br><span class="line"><span class="keyword">public</span> ResultSet <span class="title function_">execute</span><span class="params">(String stmt)</span> <span class="keyword">throws</span> IOErrorException &#123;</span><br><span class="line">    <span class="comment">//传入sessionId进行RPC请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultSet</span>(connection.execute(sessionID, stmt), timezoneOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用thrift接口，传入sessionId和语句进行nebula服务端请求</span></span><br><span class="line"><span class="keyword">public</span> ExecutionResponse <span class="title function_">executeWithParameter</span><span class="params">(<span class="type">long</span> sessionId, <span class="type">byte</span>[] stmt, Map parameterMap)</span> <span class="keyword">throws</span> TException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ContextStack</span> <span class="variable">ctx</span> <span class="operator">=</span> getContextStack(<span class="string">&quot;GraphService.executeWithParameter&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="built_in">this</span>.setContextStack(ctx);</span><br><span class="line">  send_executeWithParameter(sessionId, stmt, parameterMap);</span><br><span class="line">  <span class="keyword">return</span> recv_executeWithParameter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nebula-graphd接收client的授权请求，并返回sessionId</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GraphService::<span class="built_in">future_authenticate</span>(<span class="type">const</span> std::string&amp; username,<span class="type">const</span> std::string&amp; password)&#123;</span><br><span class="line">  <span class="comment">// 请求nebula-metad校验用户名密码</span></span><br><span class="line">  <span class="keyword">auto</span> authResult = <span class="built_in">auth</span>(username, password);</span><br><span class="line">  <span class="keyword">if</span> (!authResult.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">//用户密码错误</span></span><br><span class="line">    ctx-&gt;<span class="built_in">resp</span>().errorCode = ErrorCode::E_BAD_USERNAME_PASSWORD;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sessionManager_-&gt;<span class="built_in">isOutOfConnections</span>()) &#123;</span><br><span class="line">    <span class="comment">//session创建过多</span></span><br><span class="line">    ctx-&gt;<span class="built_in">resp</span>().errorCode = ErrorCode::E_TOO_MANY_CONNECTIONS;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//请求nebula-metad创建会话</span></span><br><span class="line">  sessionManager_-&gt;<span class="built_in">createSession</span>(username, clientIp, <span class="built_in">getThreadManager</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphSessionManager::<span class="built_in">createSession</span>()&#123;</span><br><span class="line">  std::string key = userName + clientIp;</span><br><span class="line">  <span class="comment">//nebula-graphd.conf中配置的max_sessions_per_ip_per_user参数值</span></span><br><span class="line">  <span class="keyword">auto</span> maxSessions = FLAGS_max_sessions_per_ip_per_user;</span><br><span class="line">  <span class="comment">//获取相同用户IP创建session数量</span></span><br><span class="line">  <span class="keyword">auto</span> uiscFindPtr = <span class="built_in">sessionCnt</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (uiscFindPtr-&gt;<span class="built_in">get</span>() &gt; maxSessions - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Error</span>(<span class="string">&quot;Create Session failed: Too many sessions created&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过metaClient创建会话</span></span><br><span class="line">  <span class="keyword">return</span> metaClient_-&gt;<span class="built_in">createSession</span>(userName, myAddr_, clientIp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetaClient::<span class="built_in">createSession</span>()&#123;</span><br><span class="line">  <span class="comment">//像nebula-metad发起RPC请求创建session</span></span><br><span class="line">  client-&gt;<span class="built_in">future_createSession</span>(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nebula-metad接收到nebula-graphd请求进行session创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到session创建请求并进行处理</span></span><br><span class="line">MetaServiceHandler::<span class="built_in">future_createSession</span>(</span><br><span class="line">    <span class="type">const</span> cpp2::CreateSessionReq&amp; req) &#123;</span><br><span class="line">  <span class="keyword">auto</span>* processor = CreateSessionProcessor::<span class="built_in">instance</span>(kvstore_);</span><br><span class="line">  <span class="built_in">RETURN_FUTURE</span>(processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateSessionProcessor::<span class="built_in">process</span>()&#123;</span><br><span class="line">  cpp2::Session session;</span><br><span class="line">  <span class="comment">// 创建sessionId，以当前时间微妙作为值</span></span><br><span class="line">  session.<span class="built_in">session_id_ref</span>() = time::WallClock::<span class="built_in">fastNowInMicroSec</span>();</span><br><span class="line">  session.<span class="built_in">create_time_ref</span>() = session.<span class="built_in">get_session_id</span>();</span><br><span class="line">  session.<span class="built_in">update_time_ref</span>() = session.<span class="built_in">get_create_time</span>();</span><br><span class="line">  session.<span class="built_in">user_name_ref</span>() = user;</span><br><span class="line">  session.<span class="built_in">graph_addr_ref</span>() = req.<span class="built_in">get_graph_addr</span>();</span><br><span class="line">  session.<span class="built_in">client_ip_ref</span>() = req.<span class="built_in">get_client_ip</span>();</span><br><span class="line">  std::vector&lt;kvstore::KV&gt; data;</span><br><span class="line">  <span class="comment">//构建kv引擎键值对，key为sessionId，value为会话信息</span></span><br><span class="line">  data.<span class="built_in">emplace_back</span>(MetaKeyUtils::<span class="built_in">sessionKey</span>(session.<span class="built_in">get_session_id</span>()),</span><br><span class="line">                    MetaKeyUtils::<span class="built_in">sessionVal</span>(session));</span><br><span class="line">  resp_.<span class="built_in">session_ref</span>() = session;</span><br><span class="line">  <span class="comment">//调用kv引擎的put方法</span></span><br><span class="line">  ret = <span class="built_in">doSyncPut</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> PartitionID kDefaultPartId = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> GraphSpaceID kDefaultSpaceId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用NebulaStore的put方法</span></span><br><span class="line">BaseProcessor&lt;RESP&gt;::<span class="built_in">doSyncPut</span>()&#123;</span><br><span class="line">  kvstore_-&gt;<span class="built_in">asyncMultiPut</span>(kDefaultSpaceId,kDefaultPartId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NebulaStore::<span class="built_in">asyncMultiPut</span>()&#123;</span><br><span class="line">  <span class="comment">//获取session会话分片信息，spaceId和 partId都为0</span></span><br><span class="line">  <span class="keyword">auto</span> ret = <span class="built_in">part</span>(spaceId, partId);</span><br><span class="line">  <span class="keyword">auto</span> part = nebula::<span class="built_in">value</span>(ret);</span><br><span class="line">  <span class="comment">//分片数据写入</span></span><br><span class="line">  part-&gt;<span class="built_in">asyncMultiPut</span>(std::<span class="built_in">move</span>(keyValues), std::<span class="built_in">move</span>(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Part::<span class="built_in">asyncMultiPut</span>()&#123;</span><br><span class="line">  <span class="comment">//简直编码</span></span><br><span class="line">  std::string log = <span class="built_in">encodeMultiValues</span>(OP_MULTI_PUT, keyValues);</span><br><span class="line">  <span class="comment">//通过raft协议进行数据写入</span></span><br><span class="line">  <span class="built_in">appendLogAsync</span>(source, LogType::NORMAL, std::<span class="built_in">move</span>(log))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>session的销毁</strong><br>session的销毁通过两种途径：</p>
<ol>
<li>client客户端主动signout   </li>
<li>空闲时间超过session_idle_time自动被清除。</li>
</ol>
<p>方式一、client客户端主动quit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---------nebula-client------------------</span><br><span class="line"><span class="comment">//NebulaSession中release方法退出session</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">  connection.signout(sessionID);</span><br><span class="line">  connection.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过thrift协议调用GraphService.signout方法，这里向nebula-graphd发起退出请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signout</span><span class="params">(<span class="type">long</span> sessionId)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ContextStack</span> <span class="variable">ctx</span> <span class="operator">=</span> getContextStack(<span class="string">&quot;GraphService.signout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="built_in">this</span>.setContextStack(ctx);</span><br><span class="line">  send_signout(sessionId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------nebula-graphd------------------</span><br><span class="line"><span class="comment">//接收到nebula-client的请求进行会话清除</span></span><br><span class="line">GraphService::signout(int64_t sessionId) &#123;</span><br><span class="line">  VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Sign out session &quot;</span> &lt;&lt; sessionId;</span><br><span class="line">  sessionManager_-&gt;removeSession(sessionId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用metad服务进行session的移除</span></span><br><span class="line"> GraphSessionManager::removeMultiSessions()&#123;</span><br><span class="line">  metaClient_-&gt;removeSessions(ids)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>方式二、nebula-graphd定时任务清除过期session</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GraphSessionManager::<span class="built_in">threadFunc</span>() &#123;</span><br><span class="line">  <span class="comment">//回收过期会话</span></span><br><span class="line">  <span class="built_in">reclaimExpiredSessions</span>();</span><br><span class="line">  <span class="comment">//启动下次回收任务</span></span><br><span class="line">  scavenger_-&gt;<span class="built_in">addDelayTask</span>(</span><br><span class="line">      FLAGS_session_reclaim_interval_secs * <span class="number">1000</span>, &amp;GraphSessionManager::threadFunc, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphSessionManager::<span class="built_in">reclaimExpiredSessions</span>() &#123;</span><br><span class="line">  <span class="comment">//过期session列表</span></span><br><span class="line">  std::vector&lt;SessionID&gt; expiredSessions;</span><br><span class="line">  <span class="comment">// activeSessions_为当前有效session列表，在创建session的时候进行填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter : activeSessions_) &#123;</span><br><span class="line">    <span class="type">int32_t</span> idleSecs = iter.second-&gt;<span class="built_in">idleSeconds</span>();</span><br><span class="line">    <span class="keyword">if</span> (idleSecs &lt; FLAGS_session_idle_timeout_secs) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲时间大于session_idle_timeout_secs就会加入到过期列表中</span></span><br><span class="line">    expiredSessions.<span class="built_in">emplace_back</span>(iter.first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求nebula-metad进行会话清除，根据之前创建session可知其实就是通过raft协议从rocksdb中删除sessionId为key的值</span></span><br><span class="line">metaClient_-&gt;<span class="built_in">removeSessions</span>(std::<span class="built_in">move</span>(expiredSessions))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="nebula错误日志中未知错误码如何定位原因"><a href="#nebula错误日志中未知错误码如何定位原因" class="headerlink" title="nebula错误日志中未知错误码如何定位原因"></a>nebula错误日志中未知错误码如何定位原因</h6><p>nebula错误输出有时只输出错误码，未输出错误原因，此时可通过源码src&#x2F;interface&#x2F;common.thrift文件进行搜索即可，我这里贴一些常见错误码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">E_DISCONNECTED                    = -1,     // Lost connection</span><br><span class="line">E_FAIL_TO_CONNECT                 = -2,     // Unable to establish connection</span><br><span class="line">E_RPC_FAILURE                     = -3,     // RPC failure</span><br><span class="line">E_LEADER_CHANGED                  = -4,     // Raft leader has been changed</span><br><span class="line"></span><br><span class="line">// 1xxx for graphd</span><br><span class="line">E_BAD_USERNAME_PASSWORD           = -1001,  // Authentication failed</span><br><span class="line">E_SESSION_INVALID                 = -1002,  // Invalid session</span><br><span class="line">E_SESSION_TIMEOUT                 = -1003,  // Session timeout</span><br><span class="line">E_SYNTAX_ERROR                    = -1004,  // Syntax error</span><br><span class="line">E_EXECUTION_ERROR                 = -1005,  // Execution error</span><br><span class="line">E_STATEMENT_EMPTY                 = -1006,  // Statement is empty</span><br><span class="line">E_SEMANTIC_ERROR                  = -1009,  // Semantic error</span><br><span class="line">E_TOO_MANY_CONNECTIONS            = -1010,  // Maximum number of connections exceeded</span><br><span class="line">E_PARTIAL_SUCCEEDED               = -1011,  // Access to storage failed (only some requests succeeded)</span><br><span class="line"></span><br><span class="line">// 2xxx for metad</span><br><span class="line">E_NO_HOSTS                        = -2001,  // Host does not exist</span><br><span class="line">E_EXISTED                         = -2002,  // Host already exists</span><br><span class="line">E_INVALID_HOST                    = -2003,  // Invalid host</span><br><span class="line">E_UNSUPPORTED                     = -2004,  // The current command, statement, or function is not supported</span><br><span class="line">E_NOT_DROP                        = -2005,  // Not allowed to drop</span><br><span class="line">E_BALANCER_RUNNING                = -2006,  // The balancer is running</span><br><span class="line">E_CONFIG_IMMUTABLE                = -2007,  // Configuration items cannot be changed</span><br><span class="line">E_CONFLICT                        = -2008,  // Parameters conflict with meta data</span><br><span class="line">E_SESSION_NOT_FOUND               = -2069,  // Session does not exist</span><br><span class="line"></span><br><span class="line">// 3xxx for storaged</span><br><span class="line">E_CONSENSUS_ERROR                 = -3001,  // Consensus cannot be reached during an election</span><br><span class="line">E_KEY_HAS_EXISTS                  = -3002,  // Key already exists</span><br><span class="line">E_DATA_TYPE_MISMATCH              = -3003,  // Data type mismatch</span><br><span class="line">E_INVALID_FIELD_VALUE             = -3004,  // Invalid field value</span><br><span class="line">E_INVALID_OPERATION               = -3005,  // Invalid operation</span><br><span class="line">E_NOT_NULLABLE                    = -3006,  // Current value is not allowed to be empty</span><br><span class="line">E_FIELD_UNSET                     = -3007,  // Field value must be set if the field value is NOT NULL or has no default value</span><br><span class="line">E_OUT_OF_RANGE                    = -3008,  // The value is out of the range of the current type</span><br><span class="line">E_DATA_CONFLICT_ERROR             = -3010,  // Data conflict, for index write without toss.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过深入分析 NebulaGraph 的源码，我们可以看到它在高效存储、查询、数据编码和 TTL 管理方面的设计细节。希望本文能为开发者们提供一些实用的参考，帮助大家更好地理解 NebulaGraph 的工作原理，也希望通过共同学习，推动技术进步和创新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/" data-id="cm74idav80000ig6mbyv72j7g" data-title="NebulaGraph源码解读系列一" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NebulaGraph/" rel="tag">NebulaGraph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">图数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          记录NebulaGraph从1.0升级到3.6版本的心路历程
        
      </div>
    </a>
  
  
    <a href="/2024/01/29/raft-learing/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">raft learing</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NebulaGraph/" rel="tag">NebulaGraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%87%E7%BA%A7/" rel="tag">升级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">图数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-NebulaGraph-%E6%BA%90%E7%A0%81-C/" rel="tag">图数据库 NebulaGraph 源码 C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/NebulaGraph/" style="font-size: 20px;">NebulaGraph</a> <a href="/tags/%E5%8D%87%E7%BA%A7/" style="font-size: 15px;">升级</a> <a href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">图数据库</a> <a href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-NebulaGraph-%E6%BA%90%E7%A0%81-C/" style="font-size: 10px;">图数据库 NebulaGraph 源码 C++</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 15px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/">记录NebulaGraph从1.0升级到3.6版本的心路历程</a>
          </li>
        
          <li>
            <a href="/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/">NebulaGraph源码解读系列一</a>
          </li>
        
          <li>
            <a href="/2024/01/29/raft-learing/">raft learing</a>
          </li>
        
          <li>
            <a href="/2024/01/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Jiangyiwang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
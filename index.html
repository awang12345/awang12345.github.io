<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jiangyiwang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">阿旺, 作者简介：目前就职于某头部金融科技公司，13年Java开发，开源NebulaGraph图数据库Contributer和Committer, 热衷于疑难问题解决</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-记录NebulaGraph从1-0升级到3-6版本的心路历程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T08:39:25.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/">记录NebulaGraph从1.0升级到3.6版本的心路历程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h2><p>首先来说下本文的背景信息，主要是从原先用了多年的 1.0 版本升级到 NebulaGraph 最新的 v3.6.0 版本。下面是本文可能会用到的前提信息：</p>
<ul>
<li>当前 nebula 版本：1.0</li>
<li>目标 nebula 版本：3.6</li>
<li>nebula-client版本：com.vesoft:client:1.0.0-rc4.20200323</li>
</ul>
<h2 id="一、为什么要升级"><a href="#一、为什么要升级" class="headerlink" title="一、为什么要升级?"></a>一、为什么要升级?</h2><p>相信 Nebula 社区有很多和我类似用着非最新发行版的企业用户，因为为了保障业务的稳定运行，依旧用着 2.x 版本，或者是和我们一样用着 1.0 版本。所以，很多人会问：升级？为什么要升级呢？</p>
<p>这是我的答案：3.6 版本，或者说最新发行版，会比 1.0 版本具有<strong>更高的可维护性和稳定性</strong>、<strong>更完善的周边生态</strong>。此外 1.0 版本 nebula <strong>出问题基本上很难得到解决</strong>，另外<strong>扩缩容比较麻烦</strong>。</p>
<h2 id="二、升级需要考虑的点？"><a href="#二、升级需要考虑的点？" class="headerlink" title="二、升级需要考虑的点？"></a>二、升级需要考虑的点？</h2><p>和许多依旧用着老版本的用户一样，我们其实也是做了一段时间的挣扎选择了升级。下面是我们想到的升级需要考虑到的点：</p>
<ol>
<li>nGQL 的兼容性；</li>
<li>原地升级 or 导出导入的方式？这里我们测试过，原地升级经测试不可用，而且还会影响在线业务，风险大；</li>
<li>如何保证升级不影响线上的业务；</li>
<li>如何处理升级时产生的增量数据；</li>
<li>升级后如何数据一致性比对；</li>
<li>如何进行新老 nebula 替换；</li>
</ol>
<p>如果要排个优先级的话，3 5 6 应该是重中之重。</p>
<h2 id="三、升级方案"><a href="#三、升级方案" class="headerlink" title="三、升级方案"></a>三、升级方案</h2><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/0/7/07f1594ec9ef9f5c17fbe1cbd12a9a5e70ba2206.png" alt="image|690x140"></p>
<p>这是大致的升级方案，大体分为三个部分：</p>
<h3 id="升级前准备"><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h3><p>有些准备工作需要完成：</p>
<ol>
<li>收集、整合业务线相关的所有 nGQL 并进行 3.6 版本测试，修改 nGQL 以兼容 3.6 版本 nebula。</li>
</ol>
<blockquote>
<p>注意：这里并非在原来的业务应用上进行更新，而是复制一个新的出来，因为同一个应用无法兼容两套不同版本的 nebula。</p>
</blockquote>
<ol start="2">
<li><p>编写 nebula 同步服务，这里无法使用 nebula-spark-connector 进行同步，因为 nebula 版本跨的太大了。</p>
</li>
<li><p>编写数据流量比对逻辑。</p>
</li>
<li><p>搭建 nebula3.6 版本新集群环境，这里可以临时关闭自动 Compaction 功能，来加快写入速度。</p>
</li>
</ol>
<h3 id="执行升级"><a href="#执行升级" class="headerlink" title="执行升级"></a>执行升级</h3><p>我们这里是借助了 MQ（消息队列，Message Queue）来中间处理了下数据。涉及到 MQ 的步骤有：</p>
<ol>
<li>开启同步过程增量数据写入 MQ 进行积压；</li>
<li>开启 nebula 数据同步，应用 A 从 nebula1.0 中读取出来发送到 MQ，然后应用 B 消费 MQ 消息写入到 nebula3.6；</li>
<li>同步完毕后将 MQ 中积压的增量数据写入 nebula3.6；</li>
</ol>
<h3 id="升级后处理"><a href="#升级后处理" class="headerlink" title="升级后处理"></a>升级后处理</h3><p>这里再简述下升级之后需要做的操作：</p>
<ol>
<li>数据一致性比对，通过流量复制的方式发送到新的应用上进行重放结果比对；</li>
<li>逐步切流量到新 nebula 3.6 集群；</li>
</ol>
<h3 id="内核升级的详细设计"><a href="#内核升级的详细设计" class="headerlink" title="内核升级的详细设计"></a>内核升级的详细设计</h3><p>名词说明：</p>
<ul>
<li>biz-app：业务应用 App，作用连接 nebula 1.0 进行图数据操作；</li>
<li>biz-app-new：biz-app 的复制版本，只不过改成了连接 3.6 版本 nebula，并更新 nGQL 以兼容 nebula  3.6；</li>
<li>nebula-sink-app：用于接收 nebula 3.6 版本的更新语句消息，并写入到 nebula 3.6 集群；</li>
</ul>
<h4 id="第一步：开启增量数据写入-MQ-积压"><a href="#第一步：开启增量数据写入-MQ-积压" class="headerlink" title="第一步：开启增量数据写入 MQ 积压"></a>第一步：开启增量数据写入 MQ 积压</h4><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/7/e/7e19f5e99f5e6fa3141e95b7fafd97887745d0b3.png" alt="image|538x497"></p>
<h4 id="第二步：同步-nebula1-0-数据到-3-6-集群"><a href="#第二步：同步-nebula1-0-数据到-3-6-集群" class="headerlink" title="第二步：同步 nebula1.0 数据到 3.6 集群"></a>第二步：同步 nebula1.0 数据到 3.6 集群</h4><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/e/8/e8ad17f429c2bd7e624783600ec9ce8155cda0da.png" alt="image|690x308"></p>
<h4 id="第三步：同步完毕后消费增量数据"><a href="#第三步：同步完毕后消费增量数据" class="headerlink" title="第三步：同步完毕后消费增量数据"></a>第三步：同步完毕后消费增量数据</h4><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/1/a/1a01a4cc7cdfd31abdaa5dd31ad085f273945c49.png" alt="image|690x484"></p>
<h4 id="第四步：数据一致性比对"><a href="#第四步：数据一致性比对" class="headerlink" title="第四步：数据一致性比对"></a>第四步：数据一致性比对</h4><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/8/b/8ba5b083649742e8d9fddbac5c7a43b8c36bcce3.png" alt="image|690x407"></p>
<h4 id="第五步：nebula-3-6-集群切流"><a href="#第五步：nebula-3-6-集群切流" class="headerlink" title="第五步：nebula 3.6 集群切流"></a>第五步：nebula 3.6 集群切流</h4><p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/0/7/074dd0852ca6120526058063ed0790bc878bc9db.png" alt="image|690x479"></p>
<h3 id="nebula-client-3-6-版本-SDK-改造"><a href="#nebula-client-3-6-版本-SDK-改造" class="headerlink" title="nebula-client 3.6 版本 SDK 改造"></a>nebula-client 3.6 版本 SDK 改造</h3><p>本次客户端的改造，主要是支持下面功能：主备写入同步、主备读取分流、读写 SessionPool 隔离、连接池监控、nGQL 执行监控。</p>
<p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/9/9/99d267f700a4e4370e4c91b647fa45d90b86495c.png" alt="image|690x317"></p>
<ul>
<li>主备写入同步：接收到更新请求时，同步更新主库，通过 MQ 方式异步更新备库，主库同步更新失败时会自动降级成通过 MQ 异步处理</li>
<li>主备读取分流：接收到查询请求时，先获取主备流量权重配置，根据权重配置进行流量划分</li>
<li>读写 SessionPool 隔离：为了避免读写流量差距过大导致其中一方有问题，比如：查询流量 1,000 QPS，更新才 1 TPS，就有可能存在更新一直获取不到 Session</li>
<li>连接池监控：监控获取连接、释放连接、活动连接数、空闲连接数目，利于快速排查问题</li>
<li>nGQL 执行监控：监控不同 Space 不同命令的 nGQL 执行耗时和流量，也可以输出慢 nGQL 查询语句</li>
</ul>
<h2 id="四、遇到的问题以及解决方案"><a href="#四、遇到的问题以及解决方案" class="headerlink" title="四、遇到的问题以及解决方案"></a>四、遇到的问题以及解决方案</h2><p>当然升级不是一步到位，我们也遇到了不少的问题。这里罗列了几个印象深刻的错误：</p>
<ul>
<li>导出 Timestamp 属性字段报错</li>
<li>无法导出多版本数据（Schema 发生更改）</li>
<li>每次 Scan 中断只能从头开始，无法接着上次的 cursor 继续导出</li>
<li>指定扫描单个 Edge 或者 Tag 出现磁盘 IO 使用率100%（见：<a target="_blank" rel="noopener" href="https://discuss.nebula-graph.com.cn/t/topic/15186">nebula 1.0 版本导出部分边或者点出现磁盘 IO 负载过高</a>）</li>
</ul>
<p>好在的是，这些问题我们都顺利解决了。下面来讲讲我们的解决方案：</p>
<h3 id="导出-Timestamp-属性字段报错"><a href="#导出-Timestamp-属性字段报错" class="headerlink" title="导出 Timestamp 属性字段报错"></a>导出 Timestamp 属性字段报错</h3><p>这个问题产生的原因是因为 RowReader.java 中不支持 TIMESPTMP 字段。</p>
<p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/optimized/3X/3/f/3f5bf7d1f0b5a124c622bfc8b2aa3123809b48f7_2_823x750.png" alt="image|549x500"></p>
<p>解决方案：</p>
<p>重写 RowReader 代码支持 Timestamp 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public RowReader(Schema schema, long schemaVersion) &#123;</span><br><span class="line">        this.schemaVersion = schemaVersion;</span><br><span class="line">        int idx = 0;</span><br><span class="line">        for (ColumnDef columnDef : schema.columns) &#123;</span><br><span class="line">            PropertyDef.PropertyType type = PropertyDef.PropertyType.getEnum(columnDef.getType().getType());</span><br><span class="line">            String name = columnDef.getName();</span><br><span class="line">            switch (type) &#123;</span><br><span class="line">                case BOOL:</span><br><span class="line">                    defs.add(new Pair(name, Boolean.class.getName()));</span><br><span class="line">                    break;</span><br><span class="line">                case INT:</span><br><span class="line">                // 这里加入TIMESPTMAP属性识别</span><br><span class="line">                case TIMESTAMP:</span><br><span class="line">                case VID:</span><br><span class="line">                    defs.add(new Pair(name, Long.class.getName()));</span><br><span class="line">                    break;</span><br><span class="line">                case FLOAT:</span><br><span class="line">                    defs.add(new Pair(name, Float.class.getName()));</span><br><span class="line">                    break;</span><br><span class="line">                case DOUBLE:</span><br><span class="line">                    defs.add(new Pair(name, Double.class.getName()));</span><br><span class="line">                    break;</span><br><span class="line">                case STRING:</span><br><span class="line">                    defs.add(new Pair(name, byte[].class.getName()));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Invalid type in schema: &quot; + type);</span><br><span class="line">            &#125;</span><br><span class="line">            types.add(type);</span><br><span class="line">            propertyNameIndex.put(name, idx);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public Property[] decodeValue(byte[] value, long schemaVersion) &#123;</span><br><span class="line">        List&lt;byte[]&gt; decodedResult = NebulaCodec.decode(value, defs.toArray(new Pair[defs.size()]),</span><br><span class="line">                schemaVersion);</span><br><span class="line">        Property[] properties = new Property[defs.size()];</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; defs.size(); i++) &#123;</span><br><span class="line">                String field = defs.get(i).getField();</span><br><span class="line">                PropertyType type = types.get(i);</span><br><span class="line">                byte[] data = decodedResult.get(i);</span><br><span class="line">                switch (types.get(i)) &#123;</span><br><span class="line">                    case BOOL:</span><br><span class="line">                        properties[i] = getBoolProperty(field, data);</span><br><span class="line">                        break;</span><br><span class="line">                    case INT:</span><br><span class="line">                   // 加入TIMESTAMP识别</span><br><span class="line">                    case TIMESTAMP:</span><br><span class="line">                    case VID:</span><br><span class="line">                        properties[i] = getIntProperty(field, data);</span><br><span class="line">                        break;</span><br><span class="line">                    case FLOAT:</span><br><span class="line">                        properties[i] = getFloatProperty(field, data);</span><br><span class="line">                        break;</span><br><span class="line">                    case DOUBLE:</span><br><span class="line">                        properties[i] = getDoubleProperty(field, data);</span><br><span class="line">                        break;</span><br><span class="line">                    case STRING:</span><br><span class="line">                        properties[i] = getStringProperty(field, data);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        throw new IllegalArgumentException(&quot;Invalid type in schema: &quot; + type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (BufferUnderflowException e) &#123;</span><br><span class="line">            LOGGER.error(&quot;Decode value failed: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="无法导出多版本数据（Schema-发生更改）"><a href="#无法导出多版本数据（Schema-发生更改）" class="headerlink" title="无法导出多版本数据（Schema 发生更改）"></a>无法导出多版本数据（Schema 发生更改）</h3><p>这个原因是 ScanVertexProcessor 和 ScanEdgeProcessor 仅支持一个版本的数据解析：</p>
<p><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/optimized/3X/a/d/ad99b2ad5e6aff1555659e00e3a6e3992ce2e315_2_960x748.png" alt="image|640x499"></p>
<p>解决方案：重写 ScanVertexProcessor 和 ScanEdgeProcessor 自动识别多版本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public TagItem getSpecialVersionTagItem(String spaceName, int tagId, long version) &#123;</span><br><span class="line">        if (!spaceTagItemVersions.containsKey(spaceName)) &#123;</span><br><span class="line">            Map&lt;Integer, Map&lt;Long, TagItem&gt;&gt; tagVersionMap = Maps.newHashMap();</span><br><span class="line">            List&lt;TagItem&gt; allTagItemList = getTags(spaceName);</span><br><span class="line">            if (!allTagItemList.isEmpty()) &#123;</span><br><span class="line">                allTagItemList.forEach(tagItem -&gt; tagVersionMap.computeIfAbsent(tagItem.getTag_id(), k -&gt; Maps.newHashMap()).put(tagItem.getVersion(), tagItem));</span><br><span class="line">                spaceTagItemVersions.put(spaceName, tagVersionMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Map&lt;Long, TagItem&gt;&gt; tagVersionMap = spaceTagItemVersions.get(spaceName);</span><br><span class="line">        if (Objects.isNull(tagVersionMap)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return tagVersionMap.getOrDefault(tagId, Collections.emptyMap()).get(version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private RowReader getRowReader(String spaceName, ScanVertex scanTag, Map&lt;Integer, RowReader&gt; readers) &#123;</span><br><span class="line">        int tagId = scanTag.getTagId();</span><br><span class="line">        // 解析当前tag数据的schema版本</span><br><span class="line">        long schemaVersion = NebulaUtils.parseSchemaVersion(scanTag.getValue());</span><br><span class="line">        Map&lt;Integer, Map&lt;Long, RowReader&gt;&gt; tagVersionReaderMap = spaceTagVersionReaders.computeIfAbsent(spaceName, k -&gt; new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        Map&lt;Long, RowReader&gt; versionReaderMap = tagVersionReaderMap.computeIfAbsent(tagId, k -&gt; new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        RowReader reader = versionReaderMap.get(schemaVersion);</span><br><span class="line">        if (reader != null) &#123;</span><br><span class="line">            return reader;</span><br><span class="line">        &#125;</span><br><span class="line">        //构建对应schema版本的RowReader</span><br><span class="line">        TagItem tagItem = metaClient.getSpecialVersionTagItem(spaceName, tagId, schemaVersion);</span><br><span class="line">        if (tagItem != null) &#123;</span><br><span class="line">            log.debug(&quot;Add special version tagItem | spaceName:&#123;&#125; | tagId:&#123;&#125; | schemaVersion:&#123;&#125;&quot;, spaceName, tagId, schemaVersion);</span><br><span class="line">            versionReaderMap.computeIfAbsent(schemaVersion, k -&gt; new RowReader(tagItem.schema, tagItem.version));</span><br><span class="line">            return versionReaderMap.get(schemaVersion);</span><br><span class="line">        &#125;</span><br><span class="line">        RowReader rowReader = readers.get(tagId);</span><br><span class="line">        if (rowReader == null) &#123;</span><br><span class="line">            log.error(&quot;Not match vertex reader | spaceName:&#123;&#125; | tagId:&#123;&#125; | schemaVersion:&#123;&#125; | data=&#123;&#125;&quot;, spaceName, tagId, schemaVersion, Hex.encodeHexString(scanTag.value));</span><br><span class="line">        &#125;</span><br><span class="line">        return rowReader;</span><br><span class="line">    &#125;</span><br><span class="line">//解析数据的schema版本，根据nebula源码翻译成的java代码</span><br><span class="line">public static long parseSchemaVersion(byte[] row) &#123;</span><br><span class="line">        if (row == null || row.length == 0) &#123;</span><br><span class="line">            System.err.println(&quot;Row data is empty, so there is no schema version&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // The first three bits indicate the number of bytes for the</span><br><span class="line">        // schema version. If the number is zero, no schema version</span><br><span class="line">        // presents</span><br><span class="line">        int verBytes = row[0] &gt;&gt; 5;</span><br><span class="line">        int ver = 0;</span><br><span class="line">        if (verBytes &gt; 0) &#123;</span><br><span class="line">            if (verBytes + 1 &gt; row.length) &#123;</span><br><span class="line">                // Data is too short</span><br><span class="line">                // System.err.println(&quot;Row data is too short&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            // Schema Version is stored in Little Endian</span><br><span class="line">            for (int i = 0; i &lt; verBytes; i++) &#123;</span><br><span class="line">                ver |= ((int) row[i + 1] &lt;&lt; (8 * i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ver;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="每次-Scan-中断只能从头开始，无法接着上次的-cursor-继续导出"><a href="#每次-Scan-中断只能从头开始，无法接着上次的-cursor-继续导出" class="headerlink" title="每次 Scan 中断只能从头开始，无法接着上次的 cursor 继续导出"></a>每次 Scan 中断只能从头开始，无法接着上次的 cursor 继续导出</h3><p>这个问题发生的原因是因为 StorageClient 中的 scan 方法并未支持 cursor 参数传入：<br><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/optimized/3X/f/9/f902bdbf155ad00cbfe508cd9caa8f9bb0a6d995_2_894x750.png" alt="image|596x500"></p>
<p>解决方案：重写 StorageClient 提供可传入 cursor 参数，每次 next 之后将 cursor 保存到数据库中，中断重新跑的时候使用之前的 cursor：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//增加cursor参数</span><br><span class="line">public Iterator&lt;ScanVertexResponse&gt; scanVertex(</span><br><span class="line">            String space, int part, Map&lt;String, List&lt;String&gt;&gt; returnCols, boolean allCols,</span><br><span class="line">            int limit, long startTime, long endTime, byte[] cursor) throws IOException &#123;</span><br><span class="line">        HostAndPort leader = getLeader(space, part);</span><br><span class="line">        if (Objects.isNull(leader)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Part &quot; + part + &quot; not found in space &quot; + space);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int spaceId = metaClient.getSpaceIdFromCache(space);</span><br><span class="line">        ScanVertexRequest request = new ScanVertexRequest();</span><br><span class="line">        Map&lt;Integer, List&lt;PropDef&gt;&gt; columns = getVertexReturnCols(space, returnCols);</span><br><span class="line">        request.setSpace_id(spaceId)</span><br><span class="line">                .setPart_id(part)</span><br><span class="line">                .setReturn_columns(columns)</span><br><span class="line">                .setAll_columns(allCols)</span><br><span class="line">                .setLimit(limit)</span><br><span class="line">                .setStart_time(startTime)</span><br><span class="line">                .setEnd_time(endTime)</span><br><span class="line">               //设置cursor参数到request中</span><br><span class="line">                .setCursor(cursor);</span><br><span class="line"></span><br><span class="line">        return doScanVertex(space, leader, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指定扫描单个-Edge-或者-Tag-出现磁盘-IO-使用率-100"><a href="#指定扫描单个-Edge-或者-Tag-出现磁盘-IO-使用率-100" class="headerlink" title="指定扫描单个 Edge 或者 Tag 出现磁盘 IO 使用率 100%"></a>指定扫描单个 Edge 或者 Tag 出现磁盘 IO 使用率 100%</h3><p>问题的原因：当 Space 中部分点或者边数量极大（比如几百亿），部分点或者边数据极小（比如几百万），当扫描极小的点或者边的时候就会出现磁盘 IO 使用率 100%；</p>
<p>解决方案：以扫描所有的点或者边，不指定单个 Edge 或者 Tag。</p>
<h2 id="五、nebula-同步服务设计"><a href="#五、nebula-同步服务设计" class="headerlink" title="五、nebula 同步服务设计"></a>五、nebula 同步服务设计</h2><p>设计原则：</p>
<ul>
<li>导出时不能影响线上 nebula 服务</li>
<li>尽量充分使用 nebula 服务资源进行同步</li>
<li>能够实时监控同步进度</li>
<li>可以随时 停止&#x2F;启动 同步任务</li>
</ul>
<p>设计要点：</p>
<ul>
<li>自动适配不同时间段，不同导出频率和单次扫描数据量</li>
<li>根据 nebula 服务器的压力自动调整扫描任务数和频率</li>
<li>自动将扫描任务均衡到每台 nebula 服务器，避免出现 nebula 集群服务器负载不一致的情况</li>
</ul>
<h3 id="重点问题解决"><a href="#重点问题解决" class="headerlink" title="重点问题解决"></a>重点问题解决</h3><p>这里着重讲讲如何解决一些具体的问题：</p>
<p>问题：<strong>每台 nebula-storaged 节点有着不同的 partition 分布，处理扫描任务越多 nebula-storaged 服务器负载就越高，如何实现每台 nebula-storaged 处理 Scan 扫描任务的数量一样？</strong></p>
<p>解决方案：</p>
<ol>
<li>改造 StorageClient 支持指定 storage address 进行 scan 操作；</li>
<li>通过 nebula-client 执行 show parts 拿到每个 part 对应的 leader 分布；</li>
<li>根据 part 对应 leader 分布，即可进行指定 part 同步均衡到每台 nebula-storaged 服务器上。</li>
</ol>
<p>问题：<strong>如何做自动同步流控，主要针对源 nebula，也就是从哪里进行导出</strong>。</p>
<p>主要从 3 个方面解决问题：</p>
<ol>
<li>扫描频率</li>
<li>扫描行数</li>
<li>scan 任务数</li>
</ol>
<p>扫描流控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启SCAN操作并指定游标，此游标是上次scan保存下来的</span></span><br><span class="line">                Iterator&lt;RESP&gt; iterator = scan(client, space, tagOrEdgeNameList, part, statusDomain.getNextCursor());</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isScanLimitConfigIterator</span> <span class="operator">=</span> (iterator <span class="keyword">instanceof</span> ScanLimitConfigIterator);</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isScanLimitConfigIterator) &#123;</span><br><span class="line">                        <span class="comment">//设置scan行数，这里根据不同的时间段、机器的负载返回不同的值</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">scanLimit</span> <span class="operator">=</span> nebulaScanLimitController != <span class="literal">null</span> ? nebulaScanLimitController.getLimit() : <span class="built_in">this</span>.scanLimit;</span><br><span class="line">                        ((ScanLimitConfigIterator&lt;?&gt;) iterator).setScanLimit(scanLimit);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Result&lt;RESP&gt; result = scanNext(dataProcessor, iterator);</span><br><span class="line">                    <span class="comment">//将查询结果组装成insert语句并发送到MQ</span></span><br><span class="line">                    writeResult(result);</span><br><span class="line">                    <span class="comment">//保存游标到数据库中</span></span><br><span class="line">                    saveNextCursor(result.getResp());</span><br><span class="line">                    <span class="comment">//控制扫描频率</span></span><br><span class="line">                    Optional.ofNullable(nebulaScanFlowController).ifPresent(flowController -&gt; flowController.controlConsumeFlow(storageIp));</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>scan 任务自动缩减：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">autoReduceTask</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Start autoReduceTask....&quot;</span>);</span><br><span class="line">        <span class="comment">//从数据库中查询当前处理的任务列表</span></span><br><span class="line">        List&lt;NebulaDataScanTaskEntity&gt; taskList = queryProcessingTaskList();</span><br><span class="line">        <span class="comment">//遍历处理中的任务列表，统计每台机器当前处理的任务数量，如果超过限制，则停止超出任务</span></span><br><span class="line">        List&lt;NebulaDataScanTaskEntity&gt; needCancelTaskList = calCancelTaskList(taskList);</span><br><span class="line">        <span class="keyword">if</span> (needCancelTaskList.isEmpty()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;AutoReduceTask is fail, needCancelTaskList is empty&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Long&gt; cancelTaskIdList = needCancelTaskList.stream().map(NebulaDataScanTaskEntity::getId).collect(Collectors.toSet());</span><br><span class="line">        log.info(<span class="string">&quot;Need cancel task list: &#123;&#125;&quot;</span>, cancelTaskIdList);</span><br><span class="line">        <span class="comment">//取消需要停止的任务</span></span><br><span class="line">        cancelSpecialTask(cancelTaskIdList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算需要取消的任务列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;NebulaDataScanTaskEntity&gt; <span class="title function_">calCancelTaskList</span><span class="params">(List&lt;NebulaDataScanTaskEntity&gt; taskList)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;NebulaDataScanTaskEntity&gt;&gt; nodeProcessingTaskCountMap = taskList.stream().collect(Collectors.groupingBy(NebulaDataScanTaskEntity::getScanStorageHost));</span><br><span class="line">        List&lt;NebulaDataScanTaskEntity&gt; needCancelTaskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;NebulaDataScanTaskEntity&gt;&gt; et : nodeProcessingTaskCountMap.entrySet()) &#123;</span><br><span class="line">            List&lt;NebulaDataScanTaskEntity&gt; nodeProcessingTaskList = et.getValue();</span><br><span class="line">            <span class="comment">//根据节点并发限制（也就是一个nebula-storaged节点能处理几个scan任务），计算需要停止的任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nodeConcurrencyLimit</span> <span class="operator">=</span> nebulaNodeConcurrencyLimitController.getNodeConcurrencyLimit(HostAndPort.fromString(et.getKey()).getHostText());</span><br><span class="line">            <span class="keyword">if</span> (nodeProcessingTaskList.size() &gt; nodeConcurrencyLimit) &#123;</span><br><span class="line">                <span class="comment">//这里根据id进行排序，为了解决多机器并发取消问题</span></span><br><span class="line">                Collections.sort(nodeProcessingTaskList, Comparator.comparing(NebulaDataScanTaskEntity::getScanTotalRowCount));</span><br><span class="line">                needCancelTaskList.addAll(nodeProcessingTaskList.subList(<span class="number">0</span>, nodeProcessingTaskList.size() - nodeConcurrencyLimit));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> needCancelTaskList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>流控配置信息：<br><img src="https://discuss-cdn.nebula-graph.com.cn/uploads/default/original/3X/f/9/f9e23385331cd3d46399717eac9fdf4c550033f6.png" alt="image|589x287"></p>
<hr>
<p>以上，便是我完成的内核升级工作的分享。如果有你想了解更具体的细节，请留言评论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/" data-id="cm74iu8fh00000k6me4k3bibo" data-title="记录NebulaGraph从1.0升级到3.6版本的心路历程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NebulaGraph/" rel="tag">NebulaGraph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%87%E7%BA%A7/" rel="tag">升级</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">图数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-NebulaGraph源码解读系列一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T08:27:59.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/">NebulaGraph源码解读系列一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>源码分支：</strong> release-3.6</p>
<h4 id="作者简介："><a href="#作者简介：" class="headerlink" title="作者简介："></a>作者简介：</h4><p>阿旺（奇富科技）<br>本人是一名 java 老鸟，工作内容并非 C++ 方向，平时也很少接触 C++ 语言，不懂的代码都是使用 GPT 作代码辅助解释，故难免存在准确性问题，但大体思路应该没太大问题，如有错误问题还望评论区指出回复，相互学习共同成长。以下内容源自我在使用 NebulaGraph 过程中遇到的一些问题和思考。我通过查阅源码、动手实践，解决了一些实际生产中的疑难问题。也希望借此与大家分享经验，探讨更多技术细节。同时，也想鼓励每一位技术人——不要给自己轻易设限，勇于突破边界，探索新的领域。</p>
<h5 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h5><ol>
<li>nebula目录结构说明</li>
<li>nebula启动会运行多少个rocksdb实例</li>
<li>nebula是如何查询一个点的数据</li>
<li>nebula中value是如何编码的</li>
<li>nebula中TTL是如何实现的</li>
<li>nebula中如何管理session</li>
<li>nebula错误日志中未知错误码如何定位原因</li>
</ol>
<h5 id="一、nebula源码src目录结构"><a href="#一、nebula源码src目录结构" class="headerlink" title="一、nebula源码src目录结构"></a>一、nebula源码src目录结构</h5><p><strong>src</strong><br>|-<strong>clients</strong> : 内部服务客户端，主要用于graphd、metad、storaged内部服务RPC调用<br>|-<strong>codec</strong> ：nebula数据的key-value编码和解码<br>|-<strong>daemons</strong> ：启动入口，graphd、metad、storaged启动<br>|-<strong>graph</strong> ：graphd相关业务实现，graphd主要负责处理客户端请求，属于nebula的计算层<br>|-<strong>interface</strong> : thrift接口定义，nebula采用thrift做异构语言rpc调用，nebula客户端与nebula交互接口皆定义于此<br>|-<strong>kvstore</strong> ：键值存储引擎，storaged和metad都会用到，比如：rocksdb和hbase，nebula默认采用rocksdb作为内嵌存储<br>|-<strong>meta</strong> ：元数据相关，比如：session会话、用户信息、分片信息等等，属于nebula元数据管理层<br>|-<strong>parser</strong> : 语法解析<br>|-<strong>storage</strong> : nebula存储相关，提供一些简单的kv存储和查询的接口服务给graphd调用</p>
<p><strong>温馨提示：</strong> nebula通过CMake进行编译打包，如果想了解打包过程和依赖信息见每个目录的CMakeLists.txt文件</p>
<h6 id="二、单个nebula-storaged启动时会运行多少个rocksdb实例"><a href="#二、单个nebula-storaged启动时会运行多少个rocksdb实例" class="headerlink" title="二、单个nebula-storaged启动时会运行多少个rocksdb实例"></a>二、单个nebula-storaged启动时会运行多少个rocksdb实例</h6><p><strong>结论：</strong> 数据存储磁盘目录数 *space总数<br>数据存储磁盘目录： etc&#x2F;nebula-storaged.conf中data_path<br>比如：有2个space，3个数据目录，则rocksdb实例数&#x3D;2*3&#x3D;6</p>
<p><strong>相关知识点：</strong><br>space和part分区数越多nebula-storaged启动越慢</p>
<p><strong>大体过程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.StorageDaemon::main() 程序启动入口</span><br><span class="line">2.StorageServer::start() 启动存储引擎</span><br><span class="line">3.StorageServer::getStoreInstance() 初始化存储引擎</span><br><span class="line">4.NebulaStore::init() nebula存储引擎初始化</span><br><span class="line">5.NebulaStore::loadPartFromDataPath() 通过获取data_path存储目录路径，为每个目录下space启动一个rocksdb实例，并且建立了space和kvEngine的映射关系，以及partId和part的映射关系，后面查询或者更新实则是定位数据partId，然后通过partId获取到part进行操作，part中保留了kvEngine的引用</span><br><span class="line"></span><br><span class="line">最终构建spaces_，里面包含了SpaceId和spacePart分片的映射关系，后面所有的读写都需要此映射关系操作对应的rocksdb，这里的映射关系类似于java中SpringBean</span><br><span class="line">std::unordered_map&lt;GraphSpaceID, std::shared_ptr&lt;SpacePartInfo&gt;&gt; spaces_;</span><br><span class="line">struct SpacePartInfo &#123;</span><br><span class="line">  //Part中保留了engin的引用，当前版本engine其实就是rocksdb</span><br><span class="line">  std::unordered_map&lt;PartitionID, std::shared_ptr&lt;Part&gt;&gt; parts_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt; engines_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>关键代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建storageServer并启动</span></span><br><span class="line">StorageDaemon::<span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">auto</span> storageServer = std::<span class="built_in">make_unique</span>&lt;nebula::storage::StorageServer&gt;(</span><br><span class="line">      localhost, metaAddrsRet.<span class="built_in">value</span>(), paths, FLAGS_wal_path, FLAGS_listener_path);</span><br><span class="line">    storageServer-&gt;<span class="built_in">start</span>()  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化kv存储引擎</span></span><br><span class="line">StorageServer::<span class="built_in">start</span>()&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Init kvstore&quot;</span>;</span><br><span class="line">  kvstore_ = <span class="built_in">getStoreInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化nebula存储引擎并初始化</span></span><br><span class="line">StorageServer::<span class="built_in">getStoreInstance</span>()&#123;</span><br><span class="line">    <span class="keyword">auto</span> nbStore = std::<span class="built_in">make_unique</span>&lt;kvstore::NebulaStore&gt;(</span><br><span class="line">        std::<span class="built_in">move</span>(options), ioThreadPool_, localHost_, workers_);</span><br><span class="line">    nbStore-&gt;<span class="built_in">init</span>()        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从data_path中载入part分区数据</span></span><br><span class="line">NebulaStore::<span class="built_in">init</span>()&#123;</span><br><span class="line">    <span class="built_in">loadPartFromDataPath</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历data_path目录为每个space创建一个rocksdb引擎</span></span><br><span class="line">NebulaStore::<span class="built_in">loadPartFromDataPath</span>()&#123;</span><br><span class="line">    std::vector&lt;folly::Future&lt;std::pair&lt;GraphSpaceID, std::unique_ptr&lt;KVEngine&gt;&gt;&gt;&gt; futures;</span><br><span class="line">  std::vector&lt;std::string&gt; enginesPath;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; path : options_.dataPaths_) &#123;</span><br><span class="line">    <span class="comment">//这里其实就是data_path，比如:/usr/local/nebula/data</span></span><br><span class="line">    <span class="keyword">auto</span> rootPath = folly::<span class="built_in">stringPrintf</span>(<span class="string">&quot;%s/nebula&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//获取每个data_pah子目录，其实就是space</span></span><br><span class="line">    <span class="comment">// 比如 /usr/local/nebula/data/1、/usr/local/nebula/data/2</span></span><br><span class="line">    <span class="keyword">auto</span> dirs = fs::FileUtils::<span class="built_in">listAllDirsInDir</span>(rootPath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//遍历space目录，为每个space目录创建一个rocksdb</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">      <span class="comment">//目录名称就是spaceId，比如/usr/local/nebula/data/1中的1就是spaceId</span></span><br><span class="line">      GraphSpaceID spaceId = folly::<span class="built_in">to</span>&lt;GraphSpaceID&gt;(dir);</span><br><span class="line">      <span class="comment">// 目录为0的跳过</span></span><br><span class="line">      <span class="keyword">if</span> (spaceId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// skip the system space, only handle data space here.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      enginesPath.<span class="built_in">emplace_back</span>(rootPath + <span class="string">&quot;/&quot;</span> + dir);</span><br><span class="line">      <span class="comment">//异步创建rocksdb存储引擎</span></span><br><span class="line">      futures.<span class="built_in">emplace_back</span>(<span class="built_in">newEngineAsync</span>(spaceId, path, options_.walPath_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// space和kvEngine列表的映射关系</span></span><br><span class="line">    std::unordered_map&lt;GraphSpaceID, std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt;&gt; spaceEngines;</span><br><span class="line">    <span class="comment">// 等待并获取前面的异步创建引擎列表</span></span><br><span class="line">    <span class="keyword">auto</span> tries = folly::<span class="built_in">collectAll</span>(futures).<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : tries) &#123;</span><br><span class="line">        <span class="comment">//p就是个二元组，第一个元素为space，第二个元素为kvEngine</span></span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; p = t.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">auto</span> spaceIt = spaceEngines.<span class="built_in">find</span>(p.first);</span><br><span class="line">        <span class="keyword">if</span> (spaceIt == spaceEngines.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        spaceIt = spaceEngines.<span class="built_in">emplace</span>(p.first, std::vector&lt;std::unique_ptr&lt;KVEngine&gt;&gt;()).first;</span><br><span class="line">      &#125;</span><br><span class="line">        spaceIt-&gt;second.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(p.second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有space存储引擎</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; spaceEngine : spaceEngines) &#123;</span><br><span class="line">        GraphSpaceID spaceId = spaceEngine.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; engine : spaceEngine.second) &#123;</span><br><span class="line">          <span class="comment">// part分片与part副本节点集合，后面raft需要用到</span></span><br><span class="line">          std::map&lt;PartitionID, Peers&gt; partRaftPeers;</span><br><span class="line">          partRaftPeers.<span class="built_in">emplace</span>(partId, raftPeers);</span><br><span class="line">          <span class="comment">//建立起partId和part映射关系，后面操作某partId的数据时就是通过part进行的，part中其实保留了kvEngine的引用</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : partRaftPeers) &#123;</span><br><span class="line">                <span class="keyword">auto</span> part = <span class="built_in">newPart</span>(spaceId, partId, enginePtr, isLearner, addrs);</span><br><span class="line">                <span class="keyword">auto</span> ret = iter-&gt;second-&gt;parts_.<span class="built_in">emplace</span>(partId, part);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建rocksdb引擎</span></span><br><span class="line">NebulaStore::<span class="built_in">newEngineAsync</span>() &#123;</span><br><span class="line">      engine = std::<span class="built_in">make_unique</span>&lt;RocksEngine&gt;(</span><br><span class="line">          spaceId, vIdLen, dataPath, walPath, options_.mergeOp_, cfFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="三、nebula是如何查询一个点的数据"><a href="#三、nebula是如何查询一个点的数据" class="headerlink" title="三、nebula是如何查询一个点的数据"></a>三、nebula是如何查询一个点的数据</h6><p>graphd负责接受client客户端请求，并解析 nGQL，生成查询计划，再经过优化器，最终执行executor，为了突出重点省去从接受请求开始到调用executor，而直接定位executor，这边以GetVerticesExecutor.cpp为例来探究如何查找vertex点的数据，主要探究vertexId如何定位到数据</p>
<p><strong>相关知识点</strong> </p>
<ol>
<li>part数和storaged查询并发数成正比</li>
<li>vid和partId映射计算公式: partId &#x3D; hash(vid) % numParts + 1</li>
</ol>
<p><strong>大体过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//nebula-graphd</span><br><span class="line">1.GetVerticesExecutor::getVertices() 获取多个点属性列表</span><br><span class="line">2.StorageClient::getProps() 计算vertexId对应的part，然后请求对应part分片数据</span><br><span class="line"></span><br><span class="line">//nebula-storaged</span><br><span class="line">3.GraphStorageServiceHandler::future_getProps() storagd收到graphd来的请求进行处理</span><br><span class="line">4.GetPropProcessor::doProcess()  构建tag属性查询计划并调用</span><br><span class="line">5.GetTagPropNode::doExecute()  根据vid构建rocksdb的key，然后调用NebulaStore进行获取</span><br><span class="line">6.NebulaStore::get() 通过partId定位出part，然后通过part获取对应key的信息</span><br><span class="line">7.RocksEngine::get() 从rocksdb中获取数据</span><br></pre></td></tr></table></figure>
<p><strong>关键源码</strong><br>nebula-graphd部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过上下文获取到storageClient然后调用获取属性的方法</span></span><br><span class="line">GetVerticesExecutor::<span class="built_in">getVertices</span>() &#123;</span><br><span class="line">    StorageClient *storageClient = <span class="built_in">qctx</span>()-&gt;<span class="built_in">getStorageClient</span>();</span><br><span class="line">    storageClient-&gt;<span class="built_in">getProps</span>(param,</span><br><span class="line">                 std::<span class="built_in">move</span>(vertices),</span><br><span class="line">                 gv-&gt;<span class="built_in">props</span>(),</span><br><span class="line">                 <span class="literal">nullptr</span>,</span><br><span class="line">                 gv-&gt;<span class="built_in">exprs</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">dedup</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">orderBy</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">getValidLimit</span>(),</span><br><span class="line">                 gv-&gt;<span class="built_in">filter</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过vertexId获取到part所在节点信息</span></span><br><span class="line"><span class="comment">// 请求对应节点的vertexId信息</span></span><br><span class="line"><span class="function">StorageRpcRespFuture&lt;cpp2::GetPropResponse&gt; <span class="title">StorageClient::getProps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立vertexId和part节点映射关系</span></span><br><span class="line">    <span class="keyword">auto</span> status = <span class="built_in">clusterIdsToHosts</span>(param.space, input.rows, std::<span class="built_in">move</span>(cbStatus).<span class="built_in">value</span>());</span><br><span class="line">  <span class="comment">// 为不同的节点构建对应的request</span></span><br><span class="line">  cpp2::GetPropRequest&gt; requests;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : clusters) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; host = c.first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; req = requests[host];</span><br><span class="line">    req.<span class="built_in">space_id_ref</span>() = param.space;</span><br><span class="line">    req.<span class="built_in">parts_ref</span>() = std::<span class="built_in">move</span>(c.second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用rpc请求storaged获取点的属性信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">collectResponse</span>(</span><br><span class="line">      param.evb, std::<span class="built_in">move</span>(requests), [](ThriftClientType* client, <span class="type">const</span> cpp2::GetPropRequest&amp; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> client-&gt;<span class="built_in">future_getProps</span>(r);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过（vid % numParts + 1）计算出对应的part</span></span><br><span class="line"><span class="comment">// 这种方式也预示着space设定的分区数量一旦创建不可更改，否则数据就会映射不上</span></span><br><span class="line">StorageClientBase::<span class="built_in">clusterIdsToHosts</span>()&#123;</span><br><span class="line">    <span class="comment">//获取space空间有多少个part</span></span><br><span class="line">  <span class="keyword">auto</span> status = metaClient_-&gt;<span class="built_in">partsNum</span>(spaceId);</span><br><span class="line">  std::unordered_map&lt;PartitionID, HostAddr&gt; leaders;</span><br><span class="line">    <span class="comment">//建立起partId和leader节点的映射关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> partId = <span class="number">1</span>; partId &lt;= numParts; ++partId) &#123;</span><br><span class="line">    <span class="keyword">auto</span> leader = <span class="built_in">getLeader</span>(spaceId, partId);</span><br><span class="line">    leaders[partId] = std::<span class="built_in">move</span>(leader).<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; id : ids) &#123;</span><br><span class="line">        <span class="comment">// 计算vid对应的partId</span></span><br><span class="line">        PartitionID part = vid % numParts + <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; leader = leaders[part];</span><br><span class="line">        clusters[leader][part].<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(id));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clusters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nebula-storaged部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">folly::Future&lt;cpp2::GetPropResponse&gt; <span class="title">GraphStorageServiceHandler::future_getProps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cpp2::GetPropRequest&amp; req)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* processor = GetPropProcessor::<span class="built_in">instance</span>(env_, &amp;kGetPropCounters, readerPool_.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RETURN_FUTURE</span>(processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetPropProcessor::<span class="built_in">doProcess</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!FLAGS_query_concurrently) &#123;</span><br><span class="line">     <span class="comment">//为了方便理解，这里直接选择单线程</span></span><br><span class="line">      <span class="built_in">runInSingleThread</span>(req);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">runInMultipleThread</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetPropProcessor::<span class="built_in">runInSingleThread</span>()&#123;</span><br><span class="line">    <span class="comment">// 构建tag查询计划,这个计划相当于构建一个DAG</span></span><br><span class="line">    <span class="comment">// 里面有完整的依赖信息</span></span><br><span class="line">    <span class="keyword">auto</span> plan = <span class="built_in">buildTagPlan</span>(&amp;contexts_.<span class="built_in">front</span>(), &amp;resultDataSet_);</span><br><span class="line">    <span class="comment">// 遍历待查询的part分区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; partEntry : req.<span class="built_in">get_parts</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> partId = partEntry.first;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : partEntry.second) &#123;</span><br><span class="line">        <span class="keyword">auto</span> vId = row.values[<span class="number">0</span>].<span class="built_in">getStr</span>();</span><br><span class="line">        <span class="comment">// 执行查询计划</span></span><br><span class="line">        plan.<span class="built_in">go</span>(partId, vId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建执行计划DAG</span></span><br><span class="line">GetPropProcessor::<span class="built_in">buildTagPlan</span>(RuntimeContext* context,</span><br><span class="line">                                                     nebula::DataSet* result) &#123;</span><br><span class="line">  StoragePlan&lt;VertexID&gt; plan;</span><br><span class="line">  std::vector&lt;TagNode*&gt; tags;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tc : tagContext_.propContexts_) &#123;</span><br><span class="line">    <span class="comment">// TagNode获取vid指定tag的属性列表，TagNode will return a DataSet of specified props of tagId</span></span><br><span class="line">    <span class="comment">// 这里面就有从rocksdb中读取tag的value属性</span></span><br><span class="line">    <span class="comment">// 查询语句指定多少个tag，这里就会有多少个TagNode</span></span><br><span class="line">    <span class="comment">// 比如：fetch prop on tag_1,tag_2,tag_3 idxxx,那这里就有3个TagNode</span></span><br><span class="line">    <span class="keyword">auto</span> tag = std::<span class="built_in">make_unique</span>&lt;TagNode&gt;(context, &amp;tagContext_, tc.first, &amp;tc.second);</span><br><span class="line">    tags.<span class="built_in">emplace_back</span>(tag.<span class="built_in">get</span>());</span><br><span class="line">    plan.<span class="built_in">addNode</span>(std::<span class="built_in">move</span>(tag));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// GetTagPropNode用于收集vid对应多个tag的属性</span></span><br><span class="line">  <span class="keyword">auto</span> output = std::<span class="built_in">make_unique</span>&lt;GetTagPropNode&gt;(</span><br><span class="line">      context, tags, result, filter_ == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : filter_-&gt;<span class="built_in">clone</span>(), limit_, &amp;tagContext_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>* tag : tags) &#123;</span><br><span class="line">    output-&gt;<span class="built_in">addDependency</span>(tag);</span><br><span class="line">  &#125;</span><br><span class="line">  plan.<span class="built_in">addNode</span>(std::<span class="built_in">move</span>(output));</span><br><span class="line">  <span class="keyword">return</span> plan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TagNode::<span class="built_in">doExecute</span>()&#123;</span><br><span class="line">    <span class="comment">// 根据vid和tagId构建rocksdb中key</span></span><br><span class="line">    key_ = NebulaKeyUtils::<span class="built_in">tagKey</span>(context_-&gt;<span class="built_in">vIdLen</span>(), partId, vId, tagId_);</span><br><span class="line">    <span class="comment">// 从响应分片的rocksdb中获取value，此value为经过RowWriter编码的value</span></span><br><span class="line">    ret = context_-&gt;<span class="built_in">env</span>()-&gt;kvstore_-&gt;<span class="built_in">get</span>(context_-&gt;<span class="built_in">spaceId</span>(), partId, key_, &amp;value_);</span><br><span class="line">    <span class="comment">// RowReaderWrapper设置schema和对应的value，后面用于GetTagPropNode收集prop做准备</span></span><br><span class="line">    reader_.<span class="built_in">reset</span>(*schemas_, value_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集vid对应所有tag的属性值列表</span></span><br><span class="line">GetTagPropNode::<span class="built_in">doExecute</span>()&#123;</span><br><span class="line">    <span class="comment">// 这个集合用于保存查询到的vid对应不同tag的属性集合</span></span><br><span class="line">    List row;</span><br><span class="line">    <span class="comment">// vertexId is the first column</span></span><br><span class="line">    <span class="keyword">if</span> (context_-&gt;<span class="built_in">isIntId</span>()) &#123;</span><br><span class="line">      row.<span class="built_in">emplace_back</span>(*<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">int64_t</span>*&gt;(vId.<span class="built_in">data</span>()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      row.<span class="built_in">emplace_back</span>(vId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历本次要查询的所有tag</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* tagNode : tagNodes_) &#123;</span><br><span class="line">      ret = tagNode-&gt;<span class="built_in">collectTagPropsIfValid</span>(</span><br><span class="line">          <span class="comment">// 收集tagNode中属性到row中</span></span><br><span class="line">          [&amp;row, vIdLen, isIntId, tagNode, <span class="keyword">this</span>]()&#123;</span><br><span class="line">            <span class="keyword">auto</span> status = QueryUtils::<span class="built_in">collectVertexProps</span>(</span><br><span class="line">                key, vIdLen, isIntId, reader, props, row, expCtx_.<span class="built_in">get</span>(), tagNode-&gt;<span class="built_in">getTagName</span>());</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryUtils::<span class="built_in">collectVertexProps</span>()&#123;</span><br><span class="line">  <span class="comment">// 遍历tag中的属性列表，挨个的取出来放入到list中，这个list就是GetTagPropNode::doExecute中的row</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; prop : *props) &#123;</span><br><span class="line">      <span class="keyword">auto</span> value = QueryUtils::<span class="built_in">readVertexProp</span>(key, vIdLen, isIntId, reader, prop);</span><br><span class="line">      list.<span class="built_in">emplace_back</span>(value.<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性值</span></span><br><span class="line">QueryUtils::<span class="built_in">readVertexProp</span>()&#123;</span><br><span class="line">  <span class="keyword">switch</span> (prop.propInKeyType_) &#123;</span><br><span class="line">      <span class="comment">// prop in value</span></span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::NONE: &#123;</span><br><span class="line">        <span class="comment">// ddl中的属性，这里的readValue就是RowReader根据schame获取字段的offset，然后获取对应的field值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">readValue</span>(reader, prop.name_, prop.field_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::VID: &#123;</span><br><span class="line">        <span class="comment">// 属性类型为vid</span></span><br><span class="line">        <span class="keyword">auto</span> vId = NebulaKeyUtils::<span class="built_in">getVertexId</span>(vIdLen, key);</span><br><span class="line">        <span class="keyword">if</span> (isIntId) &#123;</span><br><span class="line">          <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">int64_t</span>*&gt;(vId.<span class="built_in">data</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> vId.<span class="built_in">subpiece</span>(<span class="number">0</span>, vId.<span class="built_in">find_first_of</span>(<span class="string">&#x27;\0&#x27;</span>)).<span class="built_in">toString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PropContext::PropInKeyType::TAG: &#123;</span><br><span class="line">        <span class="comment">// 属性类型为tagId</span></span><br><span class="line">        <span class="keyword">auto</span> tag = NebulaKeyUtils::<span class="built_in">getTagId</span>(vIdLen, key);</span><br><span class="line">        <span class="keyword">return</span> tag;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="四、nebula中value是如何编码的"><a href="#四、nebula中value是如何编码的" class="headerlink" title="四、nebula中value是如何编码的"></a>四、nebula中value是如何编码的</h6><p>从2.x开始起nebula使用新的编码方式version 2，由5个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt; &lt;schema version&gt; &lt;NULL flags&gt; &lt;all properties&gt; &lt;string content&gt;</span><br><span class="line">   |             |             |              |</span><br><span class="line"> 1 byte     0 - 7 bytes     0+ bytes       N bytes</span><br></pre></td></tr></table></figure>
<p><strong>header:</strong> 占用1个字节，用来标识schema version字节长度，目前取值0<del>7<br><strong>schema version：</strong> 0</del>7个字节,标识schema版本<br><strong>NULL flags:</strong> NULL字段标识，跟mysql设计类似，为NULL的字段就在对应的bit位设置为1<br><strong>all properties：</strong> 固定长度的属性值，根据schema进行排列，由于固定长度所以想获取某个字段的值可以直接计算offset+length就能拿到, 除 STRING 类型属性外，所有属性都就地存储。STRING 属性将字符串内容的偏移量存储在前 4 个字节中，将字符串的长度存储在后 4 个字节中。字符串内容将附加到编码字符串的末尾，相当于多了一层指针<br><strong>string content:</strong> 存储非固定长度的string字符串，获取string属性内容得多次计算，先计算string字符串指针位置，然后在根据指针报错的offset+length得到完整的string内容</p>
<p><strong>各类型占用内存空间大小：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL            (1 byte)</span><br><span class="line">INT8            (1 byte)</span><br><span class="line">INT16           (2 bytes)</span><br><span class="line">INT32           (4 bytes)</span><br><span class="line">INT64           (8 bytes)</span><br><span class="line">FLOAT           (4 bytes)</span><br><span class="line">DOUBLE          (8 bytes)</span><br><span class="line">STRING          (8 bytes) *</span><br><span class="line">FIXED_STRING    (Length defined in the schema)</span><br><span class="line">TIMESTAMP       (8 bytes)</span><br><span class="line">DATE            (4 bytes)</span><br><span class="line">DATETIME        (15 bytes)</span><br><span class="line">GEOGRAPHY       (8 bytes) *</span><br></pre></td></tr></table></figure>

<p><strong>关键代码：</strong><br>RowWriterV2.cpp和RowWriterV2.h</p>
<h6 id="五、nebula中TTL是如何实现的"><a href="#五、nebula中TTL是如何实现的" class="headerlink" title="五、nebula中TTL是如何实现的"></a>五、nebula中TTL是如何实现的</h6><p>nebula中TTL是通过rocksdb中KVFilter实现的，KVFilter是rocksdb对外保留的扩展接口，查询和compact时用来做数据的过滤，数据每次搜索时都会经过此Filter，nebula实现此接口用来过滤TTL过期的数据，以及rocksdb做compact时筛选出过期的数据让其删除。</p>
<p><strong>相关知识点：</strong><br>TTL到期的数据可能并未删除，仅仅只是查询不出来，如果此时加大TTL或者删除TTL，原来查询不到的数据又会查询出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVFilter在启动的rocksdb的时候就需要设置进去，所以这里直接看rocksdb启动的代码即可</span></span><br><span class="line">StorageServer::<span class="built_in">getStoreInstance</span>()&#123;</span><br><span class="line">	kvstore::KVOptions options;</span><br><span class="line">	<span class="comment">// 这个StorageCompactionFilter就是nebula给予VKFilter实现的</span></span><br><span class="line">	options.compaction_filter_factory = std::<span class="built_in">make_unique</span>&lt;StorageCompactionFilterFactoryBuilder&gt;(schemaMan_.<span class="built_in">get</span>(), indexMan_.<span class="built_in">get</span>());</span><br><span class="line">	status = rocksdb::DB::<span class="built_in">Open</span>(options, path, &amp;db);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StorageCompactionFilter</span> <span class="keyword">final</span> : <span class="keyword">public</span> kvstore::KVFilter &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里是filter的入口</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">filter</span><span class="params">(<span class="type">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">              GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &lt; FLAGS_min_level_for_custom_filter) &#123;</span><br><span class="line">      <span class="comment">// for upper level such as L0/L1, we don&#x27;t go through the custom</span></span><br><span class="line">      <span class="comment">// validation to achieve better performance</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isTag</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">tagValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isEdge</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">edgeValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IndexKeyUtils::<span class="built_in">isIndexKey</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">indexValid</span>(spaceId, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!FLAGS_use_vertex_key &amp;&amp; NebulaKeyUtils::<span class="built_in">isVertex</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NebulaKeyUtils::<span class="built_in">isLock</span>(vIdLen_, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="built_in">lockValid</span>(spaceId, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// skip uuid/system/operation</span></span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Skip the system key inside, key &quot;</span> &lt;&lt; key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断tag是否有效,这里其实就是比对ttl字段的值对比当前时间是否超过ttl</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">tagValid</span><span class="params">(GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ttlExpired</span>(schema.<span class="built_in">get</span>(), reader.<span class="built_in">get</span>())) &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Ttl expired&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//判断边是否过期</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">edgeValid</span><span class="params">(GraphSpaceID spaceId,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> folly::StringPiece&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> folly::StringPiece&amp; val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ttlExpired</span>(schema.<span class="built_in">get</span>(), reader.<span class="built_in">get</span>())) &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Ttl expired&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// TODO(panda) Optimize the method in the future</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ttlExpired</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                  nebula::RowReaderWrapper* reader)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (schema == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ttl = CommonUtils::<span class="built_in">ttlProps</span>(schema);</span><br><span class="line">    <span class="comment">// Only support the specified ttl_col mode</span></span><br><span class="line">    <span class="comment">// Not specifying or non-positive ttl_duration behaves like ttl_duration =</span></span><br><span class="line">    <span class="comment">// infinity</span></span><br><span class="line">    <span class="keyword">if</span> (!ttl.first) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里比对数据的ttl字段的值和当前时间，如果过期就返回true</span></span><br><span class="line">    <span class="keyword">return</span> CommonUtils::<span class="built_in">checkDataExpiredForTTL</span>(schema, reader, ttl.second.second, ttl.second.first);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ttlExpired</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema, <span class="type">const</span> Value&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (schema == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ttl = CommonUtils::<span class="built_in">ttlProps</span>(schema);</span><br><span class="line">    <span class="keyword">if</span> (!ttl.first) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CommonUtils::<span class="built_in">checkDataExpiredForTTL</span>(schema, v, ttl.second.second, ttl.second.first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断ttl是否过期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CommonUtils::checkDataExpiredForTTL</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> Value&amp; v,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; ttlCol,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> ttlDuration)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; ftype = schema-&gt;<span class="built_in">getFieldType</span>(ttlCol);</span><br><span class="line">  <span class="keyword">if</span> (ftype != nebula::cpp2::PropertyType::TIMESTAMP &amp;&amp;</span><br><span class="line">      ftype != nebula::cpp2::PropertyType::INT64) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> now;</span><br><span class="line">  <span class="comment">// The unit of ttl expiration unit is controlled by user, we just use a gflag here.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_ttl_use_ms) &#123;</span><br><span class="line">    now = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    now = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(t.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the value is not INT type (sush as NULL), it will never expire.</span></span><br><span class="line">  <span class="comment">// TODO (sky) : DateTime</span></span><br><span class="line">  <span class="keyword">if</span> (v.<span class="built_in">isInt</span>() &amp;&amp; (now &gt; (v.<span class="built_in">getInt</span>() + ttlDuration))) &#123;</span><br><span class="line">    <span class="built_in">VLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;ttl expired&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ddl的schema里面读取ttl_duration和ttl_col字段</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">int64_t</span>, std::string&gt;&gt; CommonUtils::<span class="built_in">ttlProps</span>(</span><br><span class="line">    <span class="type">const</span> meta::NebulaSchemaProvider* schema) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(schema != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* ns = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> meta::NebulaSchemaProvider*&gt;(schema);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sp = ns-&gt;<span class="built_in">getProp</span>();</span><br><span class="line">  <span class="type">int64_t</span> duration = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (sp.<span class="built_in">get_ttl_duration</span>()) &#123;</span><br><span class="line">    duration = *sp.<span class="built_in">get_ttl_duration</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::string col;</span><br><span class="line">  <span class="keyword">if</span> (sp.<span class="built_in">get_ttl_col</span>()) &#123;</span><br><span class="line">    col = *sp.<span class="built_in">get_ttl_col</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(!(duration &lt;= <span class="number">0</span> || col.<span class="built_in">empty</span>()), std::<span class="built_in">make_pair</span>(duration, col));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取ttl_col字段的值</span></span><br><span class="line"><span class="function">StatusOr&lt;Value&gt; <span class="title">CommonUtils::ttlValue</span><span class="params">(<span class="type">const</span> meta::NebulaSchemaProvider* schema,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      RowReaderWrapper* reader)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(schema != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* ns = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> meta::NebulaSchemaProvider*&gt;(schema);</span><br><span class="line">  <span class="keyword">auto</span> ttlProp = <span class="built_in">ttlProps</span>(ns);</span><br><span class="line">  <span class="keyword">if</span> (!ttlProp.first) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reader-&gt;<span class="built_in">getValueByName</span>(std::<span class="built_in">move</span>(ttlProp).second.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="六、nebula中是如何管理session的"><a href="#六、nebula中是如何管理session的" class="headerlink" title="六、nebula中是如何管理session的"></a>六、nebula中是如何管理session的</h6><p>session是客户端和服务端nebula-graphd交互的凭证，session保存在nebula-metad中，session的创建和销毁都需要跟nebula-metad交互，后面将分析session的创建和销毁。<br><strong>相关知识点</strong></p>
<ol>
<li>client客户端通过sessionId来标识session</li>
<li>nebula-graphd重启不会影响已创建的session</li>
<li>nebula-metad将session保存到rocksdb中</li>
</ol>
<p><strong>总体步骤</strong></p>
<ol>
<li>nebula-client创建连接并调用用户验证创建session</li>
<li>nebula-graphd接收到client的请求验证，并调用nebula-metad进行session创建</li>
<li>nebula-metad生成sessionId并通过raft协议进行保存</li>
</ol>
<p><strong>session的创建</strong><br>nebula-client-3.6 客户端代码：创建nebula连接并认证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nebula客户端创建连接都需要先进行用户名和密码验证，nebula服务端验证成功后将返回sessionId，客户端使用sessionId作为凭证操作nebula</span></span><br><span class="line"><span class="keyword">private</span> NebulaSession <span class="title function_">createSessionObject</span><span class="params">(SessionState state)</span>&#123;</span><br><span class="line">   <span class="type">SyncConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncConnection</span>();</span><br><span class="line">   <span class="comment">//建立连接</span></span><br><span class="line">   connection.open(getAddress(), sessionPoolConfig.getTimeout());</span><br><span class="line">   <span class="comment">//用户名密码认证</span></span><br><span class="line">   <span class="type">AuthResult</span> <span class="variable">authResult</span> <span class="operator">=</span> connection.authenticate(sessionPoolConfig.getUsername(),</span><br><span class="line">                    sessionPoolConfig.getPassword());</span><br><span class="line">   <span class="comment">//将认证结果sessionId放到NebulaSession中</span></span><br><span class="line">   <span class="type">NebulaSession</span> <span class="variable">nebulaSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NebulaSession</span>(connection, authResult.getSessionId(),</span><br><span class="line">                authResult.getTimezoneOffset(), state);</span><br><span class="line">   <span class="keyword">return</span> nebulaSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NebulaSession执行语句</span></span><br><span class="line"><span class="keyword">public</span> ResultSet <span class="title function_">execute</span><span class="params">(String stmt)</span> <span class="keyword">throws</span> IOErrorException &#123;</span><br><span class="line">    <span class="comment">//传入sessionId进行RPC请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultSet</span>(connection.execute(sessionID, stmt), timezoneOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用thrift接口，传入sessionId和语句进行nebula服务端请求</span></span><br><span class="line"><span class="keyword">public</span> ExecutionResponse <span class="title function_">executeWithParameter</span><span class="params">(<span class="type">long</span> sessionId, <span class="type">byte</span>[] stmt, Map parameterMap)</span> <span class="keyword">throws</span> TException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ContextStack</span> <span class="variable">ctx</span> <span class="operator">=</span> getContextStack(<span class="string">&quot;GraphService.executeWithParameter&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="built_in">this</span>.setContextStack(ctx);</span><br><span class="line">  send_executeWithParameter(sessionId, stmt, parameterMap);</span><br><span class="line">  <span class="keyword">return</span> recv_executeWithParameter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nebula-graphd接收client的授权请求，并返回sessionId</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GraphService::<span class="built_in">future_authenticate</span>(<span class="type">const</span> std::string&amp; username,<span class="type">const</span> std::string&amp; password)&#123;</span><br><span class="line">  <span class="comment">// 请求nebula-metad校验用户名密码</span></span><br><span class="line">  <span class="keyword">auto</span> authResult = <span class="built_in">auth</span>(username, password);</span><br><span class="line">  <span class="keyword">if</span> (!authResult.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">//用户密码错误</span></span><br><span class="line">    ctx-&gt;<span class="built_in">resp</span>().errorCode = ErrorCode::E_BAD_USERNAME_PASSWORD;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sessionManager_-&gt;<span class="built_in">isOutOfConnections</span>()) &#123;</span><br><span class="line">    <span class="comment">//session创建过多</span></span><br><span class="line">    ctx-&gt;<span class="built_in">resp</span>().errorCode = ErrorCode::E_TOO_MANY_CONNECTIONS;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//请求nebula-metad创建会话</span></span><br><span class="line">  sessionManager_-&gt;<span class="built_in">createSession</span>(username, clientIp, <span class="built_in">getThreadManager</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphSessionManager::<span class="built_in">createSession</span>()&#123;</span><br><span class="line">  std::string key = userName + clientIp;</span><br><span class="line">  <span class="comment">//nebula-graphd.conf中配置的max_sessions_per_ip_per_user参数值</span></span><br><span class="line">  <span class="keyword">auto</span> maxSessions = FLAGS_max_sessions_per_ip_per_user;</span><br><span class="line">  <span class="comment">//获取相同用户IP创建session数量</span></span><br><span class="line">  <span class="keyword">auto</span> uiscFindPtr = <span class="built_in">sessionCnt</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (uiscFindPtr-&gt;<span class="built_in">get</span>() &gt; maxSessions - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Error</span>(<span class="string">&quot;Create Session failed: Too many sessions created&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过metaClient创建会话</span></span><br><span class="line">  <span class="keyword">return</span> metaClient_-&gt;<span class="built_in">createSession</span>(userName, myAddr_, clientIp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetaClient::<span class="built_in">createSession</span>()&#123;</span><br><span class="line">  <span class="comment">//像nebula-metad发起RPC请求创建session</span></span><br><span class="line">  client-&gt;<span class="built_in">future_createSession</span>(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nebula-metad接收到nebula-graphd请求进行session创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到session创建请求并进行处理</span></span><br><span class="line">MetaServiceHandler::<span class="built_in">future_createSession</span>(</span><br><span class="line">    <span class="type">const</span> cpp2::CreateSessionReq&amp; req) &#123;</span><br><span class="line">  <span class="keyword">auto</span>* processor = CreateSessionProcessor::<span class="built_in">instance</span>(kvstore_);</span><br><span class="line">  <span class="built_in">RETURN_FUTURE</span>(processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateSessionProcessor::<span class="built_in">process</span>()&#123;</span><br><span class="line">  cpp2::Session session;</span><br><span class="line">  <span class="comment">// 创建sessionId，以当前时间微妙作为值</span></span><br><span class="line">  session.<span class="built_in">session_id_ref</span>() = time::WallClock::<span class="built_in">fastNowInMicroSec</span>();</span><br><span class="line">  session.<span class="built_in">create_time_ref</span>() = session.<span class="built_in">get_session_id</span>();</span><br><span class="line">  session.<span class="built_in">update_time_ref</span>() = session.<span class="built_in">get_create_time</span>();</span><br><span class="line">  session.<span class="built_in">user_name_ref</span>() = user;</span><br><span class="line">  session.<span class="built_in">graph_addr_ref</span>() = req.<span class="built_in">get_graph_addr</span>();</span><br><span class="line">  session.<span class="built_in">client_ip_ref</span>() = req.<span class="built_in">get_client_ip</span>();</span><br><span class="line">  std::vector&lt;kvstore::KV&gt; data;</span><br><span class="line">  <span class="comment">//构建kv引擎键值对，key为sessionId，value为会话信息</span></span><br><span class="line">  data.<span class="built_in">emplace_back</span>(MetaKeyUtils::<span class="built_in">sessionKey</span>(session.<span class="built_in">get_session_id</span>()),</span><br><span class="line">                    MetaKeyUtils::<span class="built_in">sessionVal</span>(session));</span><br><span class="line">  resp_.<span class="built_in">session_ref</span>() = session;</span><br><span class="line">  <span class="comment">//调用kv引擎的put方法</span></span><br><span class="line">  ret = <span class="built_in">doSyncPut</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> PartitionID kDefaultPartId = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> GraphSpaceID kDefaultSpaceId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用NebulaStore的put方法</span></span><br><span class="line">BaseProcessor&lt;RESP&gt;::<span class="built_in">doSyncPut</span>()&#123;</span><br><span class="line">  kvstore_-&gt;<span class="built_in">asyncMultiPut</span>(kDefaultSpaceId,kDefaultPartId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NebulaStore::<span class="built_in">asyncMultiPut</span>()&#123;</span><br><span class="line">  <span class="comment">//获取session会话分片信息，spaceId和 partId都为0</span></span><br><span class="line">  <span class="keyword">auto</span> ret = <span class="built_in">part</span>(spaceId, partId);</span><br><span class="line">  <span class="keyword">auto</span> part = nebula::<span class="built_in">value</span>(ret);</span><br><span class="line">  <span class="comment">//分片数据写入</span></span><br><span class="line">  part-&gt;<span class="built_in">asyncMultiPut</span>(std::<span class="built_in">move</span>(keyValues), std::<span class="built_in">move</span>(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Part::<span class="built_in">asyncMultiPut</span>()&#123;</span><br><span class="line">  <span class="comment">//简直编码</span></span><br><span class="line">  std::string log = <span class="built_in">encodeMultiValues</span>(OP_MULTI_PUT, keyValues);</span><br><span class="line">  <span class="comment">//通过raft协议进行数据写入</span></span><br><span class="line">  <span class="built_in">appendLogAsync</span>(source, LogType::NORMAL, std::<span class="built_in">move</span>(log))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>session的销毁</strong><br>session的销毁通过两种途径：</p>
<ol>
<li>client客户端主动signout   </li>
<li>空闲时间超过session_idle_time自动被清除。</li>
</ol>
<p>方式一、client客户端主动quit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---------nebula-client------------------</span><br><span class="line"><span class="comment">//NebulaSession中release方法退出session</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">  connection.signout(sessionID);</span><br><span class="line">  connection.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过thrift协议调用GraphService.signout方法，这里向nebula-graphd发起退出请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signout</span><span class="params">(<span class="type">long</span> sessionId)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ContextStack</span> <span class="variable">ctx</span> <span class="operator">=</span> getContextStack(<span class="string">&quot;GraphService.signout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="built_in">this</span>.setContextStack(ctx);</span><br><span class="line">  send_signout(sessionId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------nebula-graphd------------------</span><br><span class="line"><span class="comment">//接收到nebula-client的请求进行会话清除</span></span><br><span class="line">GraphService::signout(int64_t sessionId) &#123;</span><br><span class="line">  VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Sign out session &quot;</span> &lt;&lt; sessionId;</span><br><span class="line">  sessionManager_-&gt;removeSession(sessionId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用metad服务进行session的移除</span></span><br><span class="line"> GraphSessionManager::removeMultiSessions()&#123;</span><br><span class="line">  metaClient_-&gt;removeSessions(ids)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>方式二、nebula-graphd定时任务清除过期session</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">GraphSessionManager::<span class="built_in">threadFunc</span>() &#123;</span><br><span class="line">  <span class="comment">//回收过期会话</span></span><br><span class="line">  <span class="built_in">reclaimExpiredSessions</span>();</span><br><span class="line">  <span class="comment">//启动下次回收任务</span></span><br><span class="line">  scavenger_-&gt;<span class="built_in">addDelayTask</span>(</span><br><span class="line">      FLAGS_session_reclaim_interval_secs * <span class="number">1000</span>, &amp;GraphSessionManager::threadFunc, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphSessionManager::<span class="built_in">reclaimExpiredSessions</span>() &#123;</span><br><span class="line">  <span class="comment">//过期session列表</span></span><br><span class="line">  std::vector&lt;SessionID&gt; expiredSessions;</span><br><span class="line">  <span class="comment">// activeSessions_为当前有效session列表，在创建session的时候进行填充</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; iter : activeSessions_) &#123;</span><br><span class="line">    <span class="type">int32_t</span> idleSecs = iter.second-&gt;<span class="built_in">idleSeconds</span>();</span><br><span class="line">    <span class="keyword">if</span> (idleSecs &lt; FLAGS_session_idle_timeout_secs) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲时间大于session_idle_timeout_secs就会加入到过期列表中</span></span><br><span class="line">    expiredSessions.<span class="built_in">emplace_back</span>(iter.first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求nebula-metad进行会话清除，根据之前创建session可知其实就是通过raft协议从rocksdb中删除sessionId为key的值</span></span><br><span class="line">metaClient_-&gt;<span class="built_in">removeSessions</span>(std::<span class="built_in">move</span>(expiredSessions))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="nebula错误日志中未知错误码如何定位原因"><a href="#nebula错误日志中未知错误码如何定位原因" class="headerlink" title="nebula错误日志中未知错误码如何定位原因"></a>nebula错误日志中未知错误码如何定位原因</h6><p>nebula错误输出有时只输出错误码，未输出错误原因，此时可通过源码src&#x2F;interface&#x2F;common.thrift文件进行搜索即可，我这里贴一些常见错误码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">E_DISCONNECTED                    = -1,     // Lost connection</span><br><span class="line">E_FAIL_TO_CONNECT                 = -2,     // Unable to establish connection</span><br><span class="line">E_RPC_FAILURE                     = -3,     // RPC failure</span><br><span class="line">E_LEADER_CHANGED                  = -4,     // Raft leader has been changed</span><br><span class="line"></span><br><span class="line">// 1xxx for graphd</span><br><span class="line">E_BAD_USERNAME_PASSWORD           = -1001,  // Authentication failed</span><br><span class="line">E_SESSION_INVALID                 = -1002,  // Invalid session</span><br><span class="line">E_SESSION_TIMEOUT                 = -1003,  // Session timeout</span><br><span class="line">E_SYNTAX_ERROR                    = -1004,  // Syntax error</span><br><span class="line">E_EXECUTION_ERROR                 = -1005,  // Execution error</span><br><span class="line">E_STATEMENT_EMPTY                 = -1006,  // Statement is empty</span><br><span class="line">E_SEMANTIC_ERROR                  = -1009,  // Semantic error</span><br><span class="line">E_TOO_MANY_CONNECTIONS            = -1010,  // Maximum number of connections exceeded</span><br><span class="line">E_PARTIAL_SUCCEEDED               = -1011,  // Access to storage failed (only some requests succeeded)</span><br><span class="line"></span><br><span class="line">// 2xxx for metad</span><br><span class="line">E_NO_HOSTS                        = -2001,  // Host does not exist</span><br><span class="line">E_EXISTED                         = -2002,  // Host already exists</span><br><span class="line">E_INVALID_HOST                    = -2003,  // Invalid host</span><br><span class="line">E_UNSUPPORTED                     = -2004,  // The current command, statement, or function is not supported</span><br><span class="line">E_NOT_DROP                        = -2005,  // Not allowed to drop</span><br><span class="line">E_BALANCER_RUNNING                = -2006,  // The balancer is running</span><br><span class="line">E_CONFIG_IMMUTABLE                = -2007,  // Configuration items cannot be changed</span><br><span class="line">E_CONFLICT                        = -2008,  // Parameters conflict with meta data</span><br><span class="line">E_SESSION_NOT_FOUND               = -2069,  // Session does not exist</span><br><span class="line"></span><br><span class="line">// 3xxx for storaged</span><br><span class="line">E_CONSENSUS_ERROR                 = -3001,  // Consensus cannot be reached during an election</span><br><span class="line">E_KEY_HAS_EXISTS                  = -3002,  // Key already exists</span><br><span class="line">E_DATA_TYPE_MISMATCH              = -3003,  // Data type mismatch</span><br><span class="line">E_INVALID_FIELD_VALUE             = -3004,  // Invalid field value</span><br><span class="line">E_INVALID_OPERATION               = -3005,  // Invalid operation</span><br><span class="line">E_NOT_NULLABLE                    = -3006,  // Current value is not allowed to be empty</span><br><span class="line">E_FIELD_UNSET                     = -3007,  // Field value must be set if the field value is NOT NULL or has no default value</span><br><span class="line">E_OUT_OF_RANGE                    = -3008,  // The value is out of the range of the current type</span><br><span class="line">E_DATA_CONFLICT_ERROR             = -3010,  // Data conflict, for index write without toss.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过深入分析 NebulaGraph 的源码，我们可以看到它在高效存储、查询、数据编码和 TTL 管理方面的设计细节。希望本文能为开发者们提供一些实用的参考，帮助大家更好地理解 NebulaGraph 的工作原理，也希望通过共同学习，推动技术进步和创新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/" data-id="cm74idav80000ig6mbyv72j7g" data-title="NebulaGraph源码解读系列一" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NebulaGraph/" rel="tag">NebulaGraph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">图数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-raft-learing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/29/raft-learing/" class="article-date">
  <time class="dt-published" datetime="2024-01-29T06:06:38.000Z" itemprop="datePublished">2024-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/29/raft-learing/">raft learing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/29/raft-learing/" data-id="clryj98r40000yk6m0jax2p5p" data-title="raft learing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/29/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-01-29T06:04:19.770Z" itemprop="datePublished">2024-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/29/hello-world/" data-id="clryizp4h0000wg6m9lgz3tov" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NebulaGraph/" rel="tag">NebulaGraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%87%E7%BA%A7/" rel="tag">升级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">图数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-NebulaGraph-%E6%BA%90%E7%A0%81-C/" rel="tag">图数据库 NebulaGraph 源码 C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/NebulaGraph/" style="font-size: 20px;">NebulaGraph</a> <a href="/tags/%E5%8D%87%E7%BA%A7/" style="font-size: 15px;">升级</a> <a href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">图数据库</a> <a href="/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-NebulaGraph-%E6%BA%90%E7%A0%81-C/" style="font-size: 10px;">图数据库 NebulaGraph 源码 C++</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 15px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/14/%E8%AE%B0%E5%BD%95NebulaGraph%E4%BB%8E1-0%E5%8D%87%E7%BA%A7%E5%88%B03-6%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/">记录NebulaGraph从1.0升级到3.6版本的心路历程</a>
          </li>
        
          <li>
            <a href="/2025/02/14/NebulaGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%B3%BB%E5%88%97%E4%B8%80/">NebulaGraph源码解读系列一</a>
          </li>
        
          <li>
            <a href="/2024/01/29/raft-learing/">raft learing</a>
          </li>
        
          <li>
            <a href="/2024/01/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Jiangyiwang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>